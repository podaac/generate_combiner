#!/usr/local/bin/perl
#  Copyright 2016, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# This Perl module allows the handling of combining SST/SST3 into a combined product to be fed to the L2P Processing module.

use File::Basename;

package generic_combiner_job_manager;

my $g_routine_name = "generic_combiner_job_manager";
my $g_package_name = "generic_combiner_job_manager";

$GHRSST_DATA_CONFIG_FILE = $ENV{GHRSST_DATA_CONFIG_FILE};

my @m_ghrsst_configuration_array;
my %m_crawler_info_lookup_table;
my %m_night_file_lookup_table;
my %m_idl_combiner_program_name;
my %m_name_extension_lookup_table;

#------------------------------------------------------------------------------------------------
sub setup_night_file_lookup_table {
    $m_night_file_lookup_table{'MODIS_A'} = 'SST4';
    $m_night_file_lookup_table{'MODIS_T'} = 'SST4';
    $m_night_file_lookup_table{'VIIRS'  } = 'SST3';
}

#------------------------------------------------------------------------------------------------
sub get_night_file_token_in_name {
    $self = shift;
    $i_data_source = shift;
    return($m_night_file_lookup_table{$i_data_source}); 
}

#------------------------------------------------------------------------------------------------
sub setup_idl_combiner_program_name {
    $m_idl_combiner_program_name{'MODIS_A'} = 'combine_netcdf_sst_and_sst4_files_to_netcdf.sav';
    $m_idl_combiner_program_name{'MODIS_T'} = 'combine_netcdf_sst_and_sst4_files_to_netcdf.sav';
    $m_idl_combiner_program_name{'VIIRS'}   = 'combine_netcdf_sst_and_sst3_files_to_netcdf.sav';
}

#------------------------------------------------------------------------------------------------
sub get_idl_combiner_program_name {
    my $self = shift;
    my $i_data_source = shift;
    return($m_idl_combiner_program_name{$m_idl_combiner_program_name});
}

#------------------------------------------------------------------------------------------------
sub setup_name_extension_lookup_table {
    $m_name_extension_lookup_table{'MODIS_A'} = "LAC";
    $m_name_extension_lookup_table{'MODIS_T'} = "LAC";
    $m_name_extension_lookup_table{'VIIRS'  } = "SNPP";
}

#------------------------------------------------------------------------------------------------
sub get_name_extension {
    my $self = shift;
    my $i_data_source = shift;
    return($m_name_extension_lookup_table{$i_data_source});
}

#------------------------------------------------------------------------------------------------
sub setup_crawler_info_lookup_table {
   # The table consists of key = processing type
   #                     value = First character of granule name.
   # Add any new dataset here.
   
   $m_crawler_info_lookup_table{'AQUA_QUICKLOOK'}   = "A";
   $m_crawler_info_lookup_table{'AQUA_REFINED'}     = "A";
   $m_crawler_info_lookup_table{'TERRA_QUICKLOOK'}  = "T";
   $m_crawler_info_lookup_table{'TERRA_REFINED'}    = "T";
   $m_crawler_info_lookup_table{'VIIRS_QUICKLOOK'}  = "V";
   $m_crawler_info_lookup_table{'VIIRS_REFINED'}    = "V";
   return(1);
}  

#------------------------------------------------------------------------------------------------
sub new
{
    my $class = shift;
    my $self = {
        m_data_source               => shift,  # VIIRS,MODIS_A,MODIS_T
        m_processing_type           => shift,  # {VIIRS_QUICKLOOK,VIIRS_REFINED,AQUA_QUICKLOOK,AQUA_REFINED,TERRA_QUICKLOOK,TERRA_REFINED}
        m_location_of_registry_file => shift,
    };
    # Print all the values just for clarification.
    bless $self, $class;

    # After blessing, we can now call some set up functions.

    $self->setup_crawler_info_lookup_table($self->{m_processing_type});
    $self->setup_night_file_lookup_table($self->{m_data_source});
    $self->setup_idl_combiner_program_name();
    $self->setup_name_extension_lookup_table();
    $self->load_ghrsst_run_config($GHRSST_DATA_CONFIG_FILE);

    return $self;
}

#------------------------------------------------------------------------------------------------
sub load_ghrsst_run_config {
#
# Subroutine loads the configuration for GHRSST data management.  It will typicaly be executed
# by other Perl routines to get the configuration definitions.
#
# Assumption:
#
#   1) The config file format is "parameter value", separated by space.

    # Returned status.  Value of 0 means ok, 1 means bad.

    my $o_status = 0;

    #
    # Get input.
    #

    my $self              = shift;
    my $i_config_filename = shift; 

    ################################################################################
    #                                                                              #
    # Read the entire list of configuration from a file an array.                  #
    # This array will be then be parsed for the parameter value                    #
    #                                                                              #
    ################################################################################


    open (FH, "< $i_config_filename")
        or die "load_ghrsst_run_config:Can't open file for reading $i_config_filename: $!";

    @m_ghrsst_configuration_array = <FH>;
    close (FH);

    # ---------- Close up shop ----------
    return ($o_status);

} # end sub load_ghrsst_run_config

#------------------------------------------------------------------------------------------------
sub get_ghrsst_config {
#
# Subroutine returns the value of a given parameter.
#
# Assumption:
#
#   1) The config file format is "parameter value", separated by space.
#   2) The array m_ghrsst_configuration_array has been filled in by function load_ghrsst_run_config().
#   3) First parameter found is the parameter returned.
#   4) Parameter in is all in UPPERCASE.
#
#------------------------------------------------------------------------------------------------

    #
    # Get input.
    #

    my $self             = shift;
    my $i_parameter_name =  shift;  #Case is important.

    #
    # Returned value.   Start with a blank.  Returned blank if cannot find parameter.
    #

    my $o_value = "";

    my $debug_module = "generic_combiner_job_manager::get_ghrsst_config:";
    my $debug_mode   = 0;

    #
    # Search through the entire array for the parameter name and return the value.
    # Note: no error checking.
    #

    my $config_array_size = @m_ghrsst_configuration_array;
    my $found_name        = 0;
    my $array_index       = 0;

    while (!$found_name && $array_index < $config_array_size) {

        # Remove leading blanks.

        my $a_line = $m_ghrsst_configuration_array[$array_index];
        $a_line =~ s/^\s+//;
        $a_line =~ s/\s+$//;

        if ($debug_mode) {
            print $debug_module . "array_index [$array_index] config_array_size [$config_array_size] i_parameter_name [$i_parameter_name] a_line [$a_line]\n";
        }

        # Only process non-blank lines and lines that are not comments.

        if ((index($a_line,"#") < 0) && (length($a_line) > 0)) {

          # Parse the element for the instrument name and the time resolution.
          # The format of each element should be: instrument_field i_yyyy i_mm i_ddd e_yyyy e_mm e_ddd
          # Use ' ' to split the line into each fields.

          my @splitted_strings = split(' ',$a_line);

          # First tokens is the parameter name.  Second is the value.

          if ($debug_mode) {
              print $debug_module . "splitted_strings[0] [" . $splitted_strings[0] . "] i_parameter_name [$i_parameter_name]\n";
              print $debug_module . "found_name $found_name\n";
          }

          if ($splitted_strings[0] eq $i_parameter_name) {
                $found_name = 1;
                # Save the value to be returned.
                $o_value = $splitted_strings[1];;
          }
        }

        # Look for next element in the array.
        $array_index = $array_index + 1;
    }

    # ---------- Close up shop ----------
    return ($o_value);

} # end sub get_ghrsst_config

#------------------------------------------------------------------------------------------------
sub get_crawl_info  {
    # Get the granule search directory and granule data name prefix given the processing type.
    my $self              = shift;
    my $i_processing_type = shift;

    my $o_granule_search_directory = "";
    my $o_granule_data_name_prefix = "";
    
    $o_granule_search_directory = $self->get_ghrsst_config($i_processing_type);
    $o_granule_data_name_prefix = $m_crawler_info_lookup_table{$i_processing_type};

    if ($o_granule_search_directory eq "") { die("ERROR: Cannot get granule search directory for processing type [$i_processing_type]")};
    if ($o_granule_data_name_prefix eq "") { die("ERROR: Cannot get crawler info for processing type [$i_processing_type]")};

    return($o_granule_search_directory,$o_granule_data_name_prefix);
}

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";
}
1;
