#!/usr/local/bin/perl
#  Copyright 2016, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Program to combine the 3 files (MODIS Level 2 SST and SST4/OC HDF format) to feed to the MODIS L2P Processing.
# The SST4 is for Night observation and the Ocean Color (OC) is for Day observation.
#
# Input (required):
#
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_QUICKLOOK  -threshold_to_wait=35
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_T -processing_type=TERRA_QUICKLOOK -threshold_to_wait=35
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_REFINED    -threshold_to_wait=35
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_T -processing_type=TERRA_REFINED   -threshold_to_wait=35
#
#   where    data_source = {MODIS_A,MODIS_T}
#   and  processing_type = {AQUA_QUICKLOOK,TERRA_QUICKLOOK,AQUA_REFINED,TERRA_REFINED}
#   and threshold_to_wait is how long to wait for the SST4 or OC to show up if they are not there already.
#
# Input (optional):
#
#       -max_files=10
#       -perform_move_instead_of_copy=yes
#
#   to limit how many pairs will be combined per run and whether the script should perform a move instead of a copy to save on IO.
#   The default for the move or copy flag is to do a copy so the original file will be left untouch, useful in development and testing to keep the files
#   around for subsequent runs.
#
# Complete examples:
#
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_QUICKLOOK  -threshold_to_wait=0  -max_files=1  -perform_move_instead_of_copy=no
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_REFINED    -threshold_to_wait=0  -max_files=1  -perform_move_instead_of_copy=no
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_QUICKLOOK  -threshold_to_wait=35 -max_files=1  -perform_move_instead_of_copy=no
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_QUICKLOOK  -threshold_to_wait=35 -max_files=10 -perform_move_instead_of_copy=yes
#      perl modis_level2_combiner_historical.pl -data_source=MODIS_T -processing_type=TERRA_QUICKLOOK -threshold_to_wait=35 -max_files=10 -perform_move_instead_of_copy=yes
#
# Some notes:
#
#     1) The staging can merely be a "mv" command since the files are assumed to be on the same disk.  If the option -perform_move_instead_of_copy=yes is not
#        used, the "cp" command will be used.
#     2) The Day file has no matching SST4, only the Night file.  This script will check to see if the file is Day or Night.
#        If it is Day, a dummy name will be added to the matching pair SST/SST4.  The IDL code will be able to recognize if it is a real file.
#        Whichever file type it it, this code will wait for the value in threshold_to_wait for the SST or the OC file to show up before processing
#        since we have observed that the data provider does not stage these files in the order we expect.
#     3) If the Ocean Color (OC) file exists, it will be passed along to the IDL script to do the combine.
#        As of 9/14/2012, the data provider does not have the correct value for "Processing Version" so the handler does not know which bucket
#        to place the file to when it is downloaded.  Currently, it is written to the refined bucket, which is wrong.
#        Edit: As of late September, early October, the data provider has corrected the "Processing Version" attribute so the files are going to the
#        correct bucket.
#
# Program description:
#
#    This program is usually ran as part of a crontab.   Because it is possible for 4 instances of this script to be ran simultaneously for different
#    product types, care has been taken to make sure each script has its own input directory, output directory.
#
#    The program has these 5 distinct stages:
#
#       1 - Crawling
#       2 - Matching
#       3 - Staging
#       4 - Combining
#       5 - Cleaning
#
#    When the program start, it will crawl the given directory for a list of SST/SST4 file names.
#    It is assume that these files would have been uncompresssed already by another script.
#    If the SST is a Night file and an SST4 can be found for the same time frame as the SST
#    then the pair is qualified to be combined.  If the SST4 is not found, the holding tank will be checked.  If it is not found there neither, the age of the SST
#    will be checked to see if it passes a certain threshold.  If the threshold has passed, the SST will be combined without an SST4.
#
#    If the SST is a Night file, the SST4 will be combined.  If the SST is a Day file, the OC file will be combined if it is available.
#    If the SST is a Mixed file, it will be combine with the SST4 to create a Mixed file.
#    The SST file will also be combined with the OC file to create a Day file if the OC file is available.  If not, it will be created anyway.
#
#    There are some special logic regarding what to do with the files after they are combined.
#
#       - The SST will be deleted.
#       - The SST4 will be moved to a holding tank.
#       - The OC will be moved to a holding tank.
#
#    The holding tank is a place where the processed files are kept in case a new version of the SST arrives due to a changed checksum as observed in development. 
#    Two hours should be sufficient time spent in the holding tank. 
#    A script will be ran separately to purge these files in the holding tank since they cannot be kept for too long.
#
# Additional notes about introducing a test into this script in response to ticket #1728:
#
#    https://podaac-cm.jpl.nasa.gov/trac/ticket/1728 Module Generate: when the combiner fails to created the combined file from sst file it failed to raise SigEvent to report problem and proceeded to remove the input sst file.
#
#    If desired to observer the behavior of the program when the file(s) are failed to be combined, run the following command:
#
#    % source ~/define_modis_operation_environment_for_combiner 
#    % perl modis_level2_combiner_historical.pl -data_source=MODIS_A -processing_type=AQUA_QUICKLOOK -threshold_to_wait=35 -max_files=1 -perform_move_instead_of_copy=no -test_only=true
#
#    Assuming that the file resources/ghrsst_data_config_file.dat contains an entry like this
#
#        AQUA_QUICKLOOK   /data/dev/scratch/IO/modis/MODIS_AQUA_L2_SST_OBPG_QUICKLOOK
#
#    and that the directory /data/dev/scratch/IO/modis/MODIS_AQUA_L2_SST_OBPG_QUICKLOOK contains at least 1 SST and either an SST4 (for night file) or OC file (for day file).
#
#    The -perform_move_instead_of_copy=no will leave all input files intact and will do a copy instead of a move of the original input file.
#    The above script will process one file, deletes the combined file and set the variable o_file_created_successfully_flag to 0 to simulates a failed combined task. 
#    An ERROR sigevent will be raised, and the SST/SST4/OC files will be moved to $SCRATCH_AREA/quarantine directory instead of deleting it.
#
#------------------------------------------------------------------------------------------------

# Location of GHRSST Perl and IDL library functions.

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};
$GHRSST_IDL_LIB_DIRECTORY  = $ENV{GHRSST_IDL_LIB_DIRECTORY};

do "$GHRSST_PERL_LIB_DIRECTORY/get_ghrsst_config.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/load_ghrsst_run_config.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/actualize_directory.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/crawl_sst_sst4_directories.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/file_move_with_error_handling.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/filter_sst4_for_error_handling.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/ghrsst_notify_operator.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/register_job.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/delete_job.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/load_file_list.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/log_this.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/mkdir_with_error_handling.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/move_combined_file_to_final_location.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/move_to_holding_tank_with_error_handling.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/clean_up.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/convert_run_log_for_interprocess_communication_historical.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/is_granule_night_or_day.pl";

use Getopt::Long;
use File::Basename;
use File::Copy;

my $debug_flag = 0;

if ($ENV{GHRSST_MODIS_L2_COMBINER_DEBUG_MODE} eq "true") {
    $debug_flag = 1;
}

# Clobal variable(s)

$NUM_FILES_TO_PROCESS = 999; # Just some default number of files to process if none specified at command line.
$g_routine_name = "modis_level2_combiner";
$g_debug = 0;
$g_holding_tank_move_flag = 1;  # This flag controls whether the SST4 and OC will be removed once they have been combined.  A value of 1 will do the move.  A value of 0 will caused the files to be removed from disk.

# Some time related business.

my $begin_processing_time = localtime;

log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");

# Some variables related to sigevent.

my $sigevent_type = "information";
my $sigevent_msg = "hello there";
my $sigevent_email_to = "DUMMY_EMAIL";
my $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
if ($sigevent_url eq '') {
    print "You must defined the sigevent URL: i.e. setenv GHRSST_SIGEVENT_URL http://lanina.jpl.nasa.gov:8100\n"; 
    die ("Cannot continue until environment GHRSST_SIGEVENT_URL is defined"); 
}

my $sigevent_clause = "SIGEVENT=" . $sigevent_url . "&category=GENERATE&provider=jpl";
my $temp_dir = "/tmp/";
my $msg2report = 7;
my $sigevent_data = '';

# Get the inputs.

GetOptions("max_files=i"                     => \$max_num_files_to_process,
           "threshold_to_wait=i"             => \$threshold_to_wait_flag,
           "data_source=s"                   => \$data_source_flag,
           "processing_type=s"               => \$processing_type_flag,
           "debug_mode=s"                    => \$debug_mode_flag,
           "skip_additional_day=s"           => \$skip_additional_day_file_flag,
           "perform_move_instead_of_copy=s"  => \$perform_move_instead_of_copy_flag,
           "test_only=s"                     => \$test_only_flag,
           "job_index=i"                     => \$job_index);

# Do a sanity check on required parameters.

if ((($data_source_flag eq '') || ($processing_type_flag eq ''))  ||
    ($threshold_to_wait_flag eq '')) {
    print "modis_level2_combiner:ERROR, All parameters must be provided\n";
    print "Variables:\n\n";
    print "threshold_to_wait_flag [$threshold_to_wait_flag]\n";
    print "data_source          [$data_source_flag]\n";
    print "processing_type_flag [$processing_type_flag]\n";
    print "\n";
    print "Usage:\n";
    print "\n";
    print "    perl modis_level2_combiner.pl -data_source=MODIS_A -processing_type=AQUA_QUICKLOOK  -max_files=10 -threshold_to_wait=35 -perform_move_instead_of_copy=yes\n";
    print "\n";
    exit(0);
}

# Get the number of files to process for each batch.

if ($max_num_files_to_process != 0) {
    $NUM_FILES_TO_PROCESS = $max_num_files_to_process;
    # Save this value in environment variable so it can be available to other functions.
    $ENV{GHRSST_MODIS_L2_NUM_FILES_TO_PROCESS} = $NUM_FILES_TO_PROCESS;
}

# Set perform_move_instead_of_copy_flag to default "no" if not provided at command line.

if ($perform_move_instead_of_copy_flag eq "") {
    $perform_move_instead_of_copy_flag = "no"; 
}


# Do a sanity check on the value of perform_move_instead_of_copy_flag.  If bad value, exist.

if ($perform_move_instead_of_copy_flag eq "yes" || $perform_move_instead_of_copy_flag eq "no") {
   # Do nothing since this is what we want.
} else {
   die("modis_level2_combiner:ERROR: The values of perform_move_instead_of_copy must be yes or no");
}

# Do a sanity check on the value of the threshold to wait.

if ($threshold_to_wait_flag < 0) {
   die("modis_level2_combiner:ERROR: The values of threshold_to_wait_flag must be a positive number");
}

# Set our debug flag if specified.

if ($debug_mode_flag eq "yes") {
    $g_debug = 1;
}

#
# A place to define global variables:
#

# This next variable is our flag to create an additional Day file if a Mixed SST is found. 

$g_skip_additional_day_file_flag = 0;  # Normally, this value is 0 since we do want to create the additional Day file.

# Set g_skip_additional_day_file_flag to 1 if the skip_additional_day parameter is set to "yes".
if (($skip_additional_day_file_flag ne "") && ($skip_additional_day_file_flag eq "yes")) {
    $g_skip_additional_day_file_flag = 1;
}

$g_use_file_locking_mechanism_flag = 0;  # Flag to indicate if the file locking mechanism is to be used or not.
$g_semaphore_name = "";                  # Name of semaphore if using file locking mechanism.

# Load the nfs*lock.pl scripts if using the file locking mechanism.
if ($ENV{GHRSST_MODIS_L2_USE_FILE_LOCK} eq "true") {
    # Set this global variable so we can detect if we are using the file locking mechanism or not.
    $g_use_file_locking_mechanism_flag = 1;
    do "$GHRSST_PERL_LIB_DIRECTORY/nfs_lock_file_wrapper.pl";
    do "$GHRSST_PERL_LIB_DIRECTORY/nfs_unlock_file.pl";
}

#print "g_skip_additional_day_file_flag [$g_skip_additional_day_file_flag]\n";
#exit(0);

# Get configuration file name.

$GHRSST_DATA_CONFIG_FILE = $ENV{GHRSST_DATA_CONFIG_FILE};

# Time related variables used to keep track of how long things take.

my $program_time_start = time();
my $current_time = $program_time_start;

#
# Load GHRSST run config into memory.
#

my $l_status = load_ghrsst_run_config($GHRSST_DATA_CONFIG_FILE);

# Set the input retrieved from command line.

my $i_datatype          = "sea_surface_temperature";
my $i_datasource        = uc($data_source_flag);      # The data sources are: {MODIS_A,MODIS_T}
my $i_processing_type   = uc($processing_type_flag);  # Processing types are: {AQUA_QUICKLOOK, TERRA_QUICKLOOK, AQUA_REFINED, TERRA_REFINED} all uppercase.
my $i_threshold_to_wait = $threshold_to_wait_flag;

my $log_type      = ""; 
my $function_name = $g_routine_name;
my $log_message   = ""; 

# Register our job to prevent 2 scripts executing the same time on the same processing type.

my ($job_register_status,$job_name,$job_age) = register_job($function_name,$i_processing_type);
if ($job_register_status == 0) {
   log_this("WARN",$g_routine_name,"Job $job_name, age $job_age (in seconds) already exist.");
   exit(1);
}

# Get the directory to crawl and prefix to look for.

my $modis_search_directory = ""; 
my $modis_data_name_prefix = "";

my $use_2019_naming_pattern = "no";
if ($ENV{GHRSST_OBPG_USE_2019_NAMING_PATTERN} eq "true") {
    $use_2019_naming_pattern = "yes";
}

if ($i_processing_type eq "AQUA_QUICKLOOK") {
        $modis_search_directory = get_ghrsst_config("AQUA_QUICKLOOK");
        $modis_data_name_prefix = "A";
        if ($use_2019_naming_pattern eq "yes") {
            $modis_data_name_prefix = "AQUA_MODIS";
        }
} elsif ($i_processing_type eq "TERRA_QUICKLOOK") {
        $modis_search_directory = get_ghrsst_config("TERRA_QUICKLOOK");
        $modis_data_name_prefix = "T";
        if ($use_2019_naming_pattern eq "yes") {
            $modis_data_name_prefix = "TERRA_MODIS";
        }
} elsif ($i_processing_type eq "AQUA_REFINED") {
        $modis_search_directory = get_ghrsst_config("AQUA_REFINED");
        $modis_data_name_prefix = "A";
        if ($use_2019_naming_pattern eq "yes") {
            $modis_data_name_prefix = "AQUA_MODIS";
        }
} elsif ($i_processing_type eq "TERRA_REFINED") {
        $modis_search_directory = get_ghrsst_config("TERRA_REFINED");
        $modis_data_name_prefix = "T";
        if ($use_2019_naming_pattern eq "yes") {
            $modis_data_name_prefix = "TERRA_MODIS";
        }
} else {
        die("modis_level2_combiner:ERROR: Does recognize processing type [$i_processing_type]");
}

#------------------------------------------------------------------------------------------------
# DISTINCT_STAGE 1: Crawling
#------------------------------------------------------------------------------------------------
# Now, we have the hot directory to crawl, we can crawl for a list of files to process.

my $time_start_crawling = time();
log_this("INFO",$g_routine_name,"BEGIN_CRAWLING $modis_search_directory"); 

my ($status,$file_list_ref) = load_file_list($modis_search_directory,$i_processing_type,$job_index);
log_this("INFO",$g_routine_name,"CRAWL_STAGE " . scalar(@$file_list_ref) . " CRAWL_DIRECTORY " . $modis_search_directory); 

my $time_end_crawling = time();
my $time_spent_in_crawling = $time_end_crawling - $time_start_crawling; 
log_this("INFO",$g_routine_name,"CRAWL_DURATION " . $time_spent_in_crawling . " CRAWL_DIRECTORY " . $modis_search_directory); 

# Create a new list to igore the .md5 files if the crawling had picked them up.

my @filtered_sst_sst4_names_without_md5_files = ();

foreach $filename (@$file_list_ref) {
    if ((rindex($filename,".md5") == -1) && (rindex($filename,".lck.NFSLock") == -1)) {
        push @filtered_sst_sst4_names_without_md5_files,$filename;
    }
}

# Exit if there's nothing to do.

if (scalar(@filtered_sst_sst4_names_without_md5_files) == 0) {
    log_this("INFO",$g_routine_name,"NO_FILES_FOUND No SST/SST4/OC files found in $modis_search_directory");
    my $end_processing_time = localtime;
    log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");
    log_this("INFO",$g_routine_name,"END_PROCESSING_TIME   $end_processing_time");
    my $job_delete_status = delete_job($g_routine_name,$i_processing_type,$job_name);
    exit(0);
}

if ($g_debug) {
    $sigevent_type = "information";
    $sigevent_msg = "MODIS Level 2 Combiner starting for $i_processing_type.";
    $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
    ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
}

#------------------------------------------------------------------------------------------------
# DISTINCT_STAGE 2: Matching
#------------------------------------------------------------------------------------------------
# For historical, we expect the files to be there already so there is no need to call these functions:
#
#     filter_sst_sst4_for_combiner()
#     handle_missing_sst4_pairs()
#     handle_missing_oc_file_for_mixed()
#
# Additional note: This code should also work for forward stream.
#
# Local variables.
#

my $scratch_area = $ENV{SCRATCH_AREA};
# my $l_actualize_status = actualize_directory($scratch_area);

my @sst_sst4_filelist = @filtered_sst_sst4_names_without_md5_files;
my $num_sst_sst4_files = scalar(@sst_sst4_filelist);

# Exit if there's nothing to do.

if ($num_sst_sst4_files == 0) {
    my $end_processing_time = localtime;
    log_this("INFO",$g_routine_name,"NONE_QUALIFIED $modis_search_directory");
    log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");
    log_this("INFO",$g_routine_name,"END_PROCESSING_TIME   $end_processing_time");
    my $job_delete_status = delete_job($g_routine_name,$i_processing_type,$job_name);
    exit(0);
}

# Everything is OK, we can proceed with the combining task.

my $i_sst_filename = "";
my $i_sst4_filename = "";
my $i_oc_filename   = "DUMMY_OC_FILENAME";  # Replace this variable with the real name later.
my $i_out_filename  = "";
my $sst_filename_compressed_file = "";
my $sst4_filename_compressed_file= "";

# For every 2 names found, send them to be combined into one file by the IDL program combine_sst_and_sst4_files.pro.

my $num_files_read              = 0;
my $num_combined_files_created  = 0;
my $time_spent_in_uncompressing = 0; 
my $time_spent_in_combining     = 0; 
my $total_Bytes_in_files        = 0; 
my $total_Bytes_created_files   = 0; 

my $output_directory = $scratch_area;  # Will append the processing type to where to write the output file to.

my $name_only = "";

my $skip_idl_execution = 0;  # Flag used to skip the IDL execution.  Useful doing development to skip the IDL execution.  The normal value is 0.
if ($ENV{GHRSST_MODIS_SKIP_IDL_EXECUTION} eq 'true') {
    $skip_idl_execution = 1;
}

my $actual_number_of_granules_to_process = get_num_sst_count(\@sst_sst4_filelist);
my $index_to_sst_sst4_list = 0;

# Variables related to parallel processing.
my $num_subprocesses_started = 0;
my $MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START = 2;
my @subprocess_id_list = ();

if ($ENV{GHRSST_MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START} eq "") {
    $MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START = 2;
} else {
    $MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START = $ENV{GHRSST_MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START};
}
log_this("INFO",$g_routine_name,"MULTI_PROCESS_INFO ENV{GHRSST_MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START} [" . $ENV{GHRSST_MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START} . "]");
log_this("INFO",$g_routine_name,"MULTI_PROCESS_INFO MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START $MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START");

# By default, use the parallel processing mode unless the user decided against it.
my $use_parallel_processing_flag = 1;
my $DUMMY_PROCESS_ID = 99999;  # Set this child process id to something we don't normally expect to represent running the parent process.
my $child_pid        = $DUMMY_PROCESS_ID;  # Set this child process id to something we don't normally expect to represent running the parent process.
if ($ENV{GHRSST_MODIS_L2_USE_PARALLEL_PROCESSING} eq "false") {
    $use_parallel_processing_flag = 0;
}
log_this("INFO Use parallel processing: ", $use_parallel_processing_flag);

my $working_on_this_file = "";
my $time_start_combining;
my $combine_stage_start = time();

my $use_pipe_flag = 1; # Developer's flag to use pipe to communicate between the child processes and the parent.
# TODO: comment out next line for debugging.
#my $use_pipe_flag = 0; # Developer's flag to use pipe to communicate between the child processes and the parent.
if ($ENV{GHRSST_MODIS_L2_USE_PIPE_FLAG} eq "false") {
    $use_pipe_flag = 0;
}

my $master_pipe;       # The master_pipe will be used by the parent process to read what the child write out processing statistics.
my $child_pipe;        # The child_pipe will be used by child processes to write out processing statistics.

# Depend on which method to communicate with the sub processes, we load the appropriate functions.

if ($use_pipe_flag) {
    do "$GHRSST_PERL_LIB_DIRECTORY/write_child_pipe_for_interprocess_communication_historical.pl";
    do "$GHRSST_PERL_LIB_DIRECTORY/read_master_pipe_for_interprocess_communication_historical.pl";
    pipe($master_pipe,$child_pipe);  # Create the pipe for communication between the parent and the child processes.  The child will use child_pipe to write and parent use master_pipe to read from.
    log_this("INFO",$g_routine_name,"MASTER_PIPE_CREATE_SUCCESS");
} else {
    # Use an external file for communication between proceses.
    do "$GHRSST_PERL_LIB_DIRECTORY/write_child_file_for_interprocess_communication_historical.pl";
    do "$GHRSST_PERL_LIB_DIRECTORY/read_master_file_for_interprocess_communication_historical.pl";
    do "$GHRSST_PERL_LIB_DIRECTORY/get_filename_for_interprocess_communication_historical.pl";
    # Delete the run log if it exists.
    my $filename_for_interprocess_communication = get_filename_for_interprocess_communication_historical($scratch_area,$i_processing_type);
    if (-e $filename_for_interprocess_communication) {
        log_this("INFO",$g_routine_name,"FILE_REMOVE FILENAME_FOR_INTERPROCESS_COMMUNICATION $filename_for_interprocess_communication");
        unlink($filename_for_interprocess_communication);
    }
}

my $num_files_checked = 0;
    # Set these variables outside of the if loop so it will be set for everyone.
    my $original_sst_filename = '';
    my $staged_sst_filename   = '';
    my $o_proceed_flag = 0;
    my $o_file_age = 0;
    my $o_night_or_day = '';

#while (($index_to_sst_sst4_list < $num_sst_sst4_files) && ($num_combined_files_created < $NUM_FILES_TO_PROCESS)) {
#while (($index_to_sst_sst4_list < $num_sst_sst4_files) and (($num_combined_files_created < $NUM_FILES_TO_PROCESS) and ($num_files_checked < $NUM_FILES_TO_PROCESS))) {
while (($index_to_sst_sst4_list < $num_sst_sst4_files) and (($num_combined_files_created < $NUM_FILES_TO_PROCESS) and (2 == 2))) {

    $working_on_this_file = $sst_sst4_filelist[$index_to_sst_sst4_list];
    chomp($working_on_this_file);  # Remove the carriage return so we can print without having the extra line.

    # Skip if the name if it is not an SST.nc file.
    if (index($working_on_this_file, "SST.nc") == -1) {
        $index_to_sst_sst4_list = $index_to_sst_sst4_list + 1;
        next;
    }

    # Set these variables outside of the if loop so it will be set for everyone.
    #my $original_sst_filename = '';
    #my $staged_sst_filename   = '';
    $o_proceed_flag = 0;
    #my $o_file_age = 0;
    #my $o_night_or_day = '';

    # Move the check of files here
    if (2 == 2) {
        #------------------------------------------------------------------------------------------------
        # DISTINCT_STAGE 2.5: Check for file age.
        #------------------------------------------------------------------------------------------------

        ($o_status,$i_sst_filename,$i_sst4_filename,$i_oc_filename)  = create_stage_input_filenames($index_to_sst_sst4_list,
                                                                                                    \@sst_sst4_filelist,
                                                                                                    \@filtered_sst_sst4_names_without_md5_files,
                                                                                                    $total_Bytes_in_files,
                                                                                                    $num_files_read,
                                                                                                    $i_processing_type,
                                                                                                    $perform_move_instead_of_copy_flag,
                                                                                                    $num_combined_files_created,
                                                                                                    $actual_number_of_granules_to_process,
                                                                                                    $scratch_area);
        log_this("INFO",$g_routine_name,"STAGE_INPUT_NAMES_CHECK:o_status,i_sst_filename,i_sst4_filename,i_oc_filename: [$o_status] [$i_sst_filename] [$i_sst4_filename] [$i_oc_filename]");
        #$sigevent_msg = "early#exit#0001";
        #log_this("INFO",$g_routine_name,$sigevent_msg);

        # Important note: We have to check for the file age before staging, otherwise the file will get staged but not processed.
        # Check for the age of the file before proceeding.
        $original_sst_filename = $i_sst_filename;
        $staged_sst_filename   = '';  # We are not sending the staged file since we haven't stage it yet. 
        $o_proceed_flag = 0;
        ($o_proceed_flag,$o_file_age,$o_night_or_day) = proceed_with_processing_sst_file($original_sst_filename,$staged_sst_filename,$i_sst4_filename,$i_oc_filename,$i_threshold_to_wait);
        if ($o_proceed_flag == 0) {
            $index_to_sst_sst4_list = $index_to_sst_sst4_list + 1;
            $num_files_checked      = $num_files_checked + 1;
            $sigevent_msg = "SST_PROCEED_FLAG_FALSE: file has not passed threshold time: original_sst_filename [$original_sst_filename] o_file_age [$o_file_age] i_threshold_to_wait [$i_threshold_to_wait] o_night_or_day [$o_night_or_day]";
            log_this("INFO",$g_routine_name,$sigevent_msg);
            next;
        }
    }

    # To do parallel processing, we add the fork() call to allow the code below to run in a separate process.
    if ($use_parallel_processing_flag) {
        sleep $MAX_NUM_SECONDS_IN_BETWEEN_SUBPROCESS_START;
        $child_pid = fork();
    }

    if (!defined $child_pid) {
        log_this("ERROR",$g_routine_name,"Cannot fork on processing file " . $working_on_this_file);
        die "ERROR: Cannot fork: $!";
    } elsif (($child_pid == 0) or ($child_pid == $DUMMY_PROCESS_ID)) {
        # Only increment the num_subprocesses_started if we running as a sub process.
        if ($g_debug) {
            log_this("INFO",$g_routine_name,"MULTI_PROCESS_IN_CHECK CHILD_PID $child_pid");
        }
        if ($child_pid == 0) { 
            log_this("INFO",$g_routine_name,"MULTI_PROCESS_IN_CHILD_PROCESS_RUNNING_BEGIN " . $working_on_this_file); 
            $num_subprocesses_started = $num_subprocesses_started + 1;
        } else {
            log_this("INFO",$g_routine_name,"MULTI_PROCESS_IN_PARENT_PROCESS_RUNNING_BEGIN " . $working_on_this_file);
            $time_start_combining = time();
        }

        push @subprocess_id_list, $child_pid;

        if (2 == 3) {
            #------------------------------------------------------------------------------------------------
            # DISTINCT_STAGE 2.5: Check for file age.
            #------------------------------------------------------------------------------------------------

            ($o_status,$i_sst_filename,$i_sst4_filename,$i_oc_filename)  = create_stage_input_filenames($index_to_sst_sst4_list,
                                                                                                        \@sst_sst4_filelist,
                                                                                                        \@filtered_sst_sst4_names_without_md5_files,
                                                                                                        $total_Bytes_in_files,
                                                                                                        $num_files_read,
                                                                                                        $i_processing_type,
                                                                                                        $perform_move_instead_of_copy_flag,
                                                                                                        $num_combined_files_created,
                                                                                                        $actual_number_of_granules_to_process,
                                                                                                        $scratch_area);
            log_this("INFO",$g_routine_name,"STAGE_INPUT_NAMES_CHECK:o_status,i_sst_filename,i_sst4_filename,i_oc_filename: [$o_status] [$i_sst_filename] [$i_sst4_filename] [$i_oc_filename]"); 
            #$sigevent_msg = "early#exit#0001";
            #log_this("INFO",$g_routine_name,$sigevent_msg);

            # Important note: We have to check for the file age before staging, otherwise the file will get staged but not processed.
            # Check for the age of the file before proceeding.
            my $original_sst_filename = $i_sst_filename;
            my $staged_sst_filename   = '';  # We are not sending the staged file since we haven't stage it yet. 
            my ($o_proceed_flag,$o_file_age,$o_night_or_day) = proceed_with_processing_sst_file($original_sst_filename,$staged_sst_filename,$i_sst4_filename,$i_oc_filename,$i_threshold_to_wait);
            if ($o_proceed_flag == 0) {
                $index_to_sst_sst4_list = $index_to_sst_sst4_list + 1;
                $num_files_checked      = $num_files_checked + 1;
                $sigevent_msg = "SST_PROCEED_FLAG_FALSE: file has not passed threshold time: original_sst_filename [$original_sst_filename] o_file_age [$o_file_age] i_threshold_to_wait [$i_threshold_to_wait] o_night_or_day [$o_night_or_day]";
                log_this("INFO",$g_routine_name,$sigevent_msg);
                next;
            }
        } # End 2 == 3

        if ($o_proceed_flag == 1) {
            $sigevent_msg = "SST_PROCEED_FLAG_TRUE: file has indeed passed threshold time (or files available): original_sst_filename [$original_sst_filename] o_file_age [$o_file_age] i_threshold_to_wait [$i_threshold_to_wait] o_night_or_day [$o_night_or_day]";
            log_this("INFO",$g_routine_name,$sigevent_msg);
        }
        #$index_to_sst_sst4_list = $index_to_sst_sst4_list + 1;
        #next; 

        #exit(0);

        #------------------------------------------------------------------------------------------------
        # DISTINCT_STAGE 3: Staging
        #------------------------------------------------------------------------------------------------
        #
        # Get the pair of names from the sst_sst4_filelist and stage the files in preparation for combining.

        my $o_status = 0;
        my $time_start_uncompress = time();

        ($o_status,$num_files_read,$total_Bytes_in_files,$i_sst_filename,$i_sst4_filename,$i_oc_filename) = stage_input_files_for_combiner_historical($index_to_sst_sst4_list,
                                                                                                                                        \@sst_sst4_filelist,
                                                                                                                                        \@filtered_sst_sst4_names_without_md5_files,
                                                                                                                                        $total_Bytes_in_files,
                                                                                                                                        $num_files_read,
                                                                                                                                        $i_processing_type,
                                                                                                                                        $perform_move_instead_of_copy_flag,
                                                                                                                                        $num_combined_files_created,
                                                                                                                                        $actual_number_of_granules_to_process,
                                                                                                                                        $scratch_area);

        # If cannot stage the files, move on to the next SST name in the list.

        if ($o_status == 1) {
            $index_to_sst_sst4_list = $index_to_sst_sst4_list + 1;
            $sigevent_type = "error";
            $sigevent_msg = "Cannot stage file $i_sst_filename TO $scratch_area";
            $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
            ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
            log_this("ERROR",$g_routine_name,$sigevent_msg);
            next;
        }

        my $time_end_uncompress = time();
        my $time_duration_uncompress = $time_end_uncompress - $time_start_uncompress;
        $time_spent_in_uncompressing += ($time_end_uncompress - $time_start_uncompress); 

        #
        # Prepare the output work area by creating directory if it is not there yet.
        # 

        my $upper_level_output_directory = "";
        my $file_extension = "";
        my $night_or_day = "";

        ($night_or_day,$name_only,$i_out_filename,$upper_level_output_directory,$file_extension,$i_oc_filename) = prepare_output_work_area_with_error_handling_historical($i_sst_filename,
                                                                                                                            $i_oc_filename,
                                                                                                                            $i_processing_type,
                                                                                                                            $output_directory,
                                                                                                                            $sigevent_email_to,
                                                                                                                            $sigevent_clause,
                                                                                                                            $temp_dir,
                                                                                                                            $msg2report,
                                                                                                                            $sigevent_data);

        #------------------------------------------------------------------------------------------------
        # SPECIAL_PROCESSING: If the SST is Mixed, we combine the SST with the SST4 to create a Night file
        #                     and then go back again to combine the SST with the LAC_OC to create the Day file
        #------------------------------------------------------------------------------------------------

        my $number_of_loops_to_run = 1;  # Start out with just 1 loop since this is the normal operation.

        # If the file is Mixed, we run through the loop twice, otherwise, only run it once.
        if ($night_or_day eq 'M') {
            $number_of_loops_to_run = 2;
        }

        # If the flag g_skip_additional_day_file_flag is set to 1, we re-set the number_of_loops_to_run to 1
        # to skip the creation of the additional day file.
        if ($g_skip_additional_day_file_flag == 1) {
            $number_of_loops_to_run = 1;
        }

        # Save these names so we can refer to them again since the looping may have altered them.
        my $saved_sst4_filename = $i_sst4_filename;
        my $saved_oc_filename   = $i_oc_filename;

        my $time_start_combining = time();

        # The next 3 variables will be returned by the function verify_combined_file_is_created().  We have to declare them outside of the
        # loop otherwise they won't be available.

        my $o_file_created_successfully_flag = 0;
        my $o_actual_file_to_look = "";
        my $o_output_file_name_wild_search = "";

        my $when_processed_parameter = '';  # Will be set to 'N' if processing Night or Mixed and to 'D' if processing Day file.
        my $from_mixed_file = '';

        for ($loop_count = 1; $loop_count <= $number_of_loops_to_run; $loop_count++) {

            # Depending on what loop we are doing, we set the names of the LAC_OC or SST4 to dummy names.
            my $time_start_one_file_combining = time();
            if ($loop_count == 1) {
                # If this is the first loop and the file is either Mixed or Night, we are creating a Night file, so we reset the LAC_OC file to a dummy name.
                if (($night_or_day eq 'M') || ($night_or_day eq 'N')) {
                    $i_oc_filename = "DUMMY_OC_FILENAME";
                    $when_processed_parameter = $night_or_day;
                } else {
                    # If this is the first loop and the file is Day, we proceed as normal.
                    $when_processed_parameter = 'D';
                    $file_extension = ".LAC_GSSTD";
                }
                $from_mixed_file = '';  # If this is the first loop, this variable is blank.
            } elsif ($loop_count == 2) {
                # If this is the 2nd time we are in this loop, we are creating a Day file.
                # We reset the SST4 to a dummy name and set the LAC_OC to the original name.
                $i_sst4_filename = "DUMMY_SST4_FILENAME";
                $i_oc_filename = $saved_oc_filename;
                $when_processed_parameter = 'D';
                $file_extension = ".LAC_GSSTD";
                $from_mixed_file = 'FROM_MIXED'; # This is the 2nd loop, we know the SST file is a Mixed file, so we are creating a Day file from a Mixed SST file.
            }

            #
            # Build the actual output name of the combined file.
            #

            my $name_without_extension = "";

            # If the file has the .nc extension, get the basename differently.
            # We can also check GHRSST_PROCESSING_NETCDF_FILE environmental variable if the name does not have .nc as the case with the test files.

            if ((index($i_sst_filename,".nc") >= 0) || ($ENV{GHRSST_PROCESSING_NETCDF_FILE} eq "true")) {
                $name_without_extension = basename($name_only,".L2_LAC_SST.nc"); # Get the name without the extension.
                # Do a sanity check on the name of the file for 2019 OBPG naming pattern.
                if (index($i_name_only,"L2.SST.nc") >= 0) {
                    $name_without_extension = basename($name_only,".L2.SST.nc"); # From AQUA_MODIS.2019289042500.L2.SST.nc, get just AQUA_MODIS.2019289042500.L2.SST
                }

                log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:PATH_0001");
            } else {
                $name_without_extension = basename($name_only,".L2_LAC_SST"); # Get the name without the extension.
                log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:PATH_0002");
            }
            log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:i_sst_filename[$i_sst_filename]");
            log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:name_without_extension [$name_without_extension]");
            #exit;

            my $actual_output_fullfilename = $upper_level_output_directory . "/". $name_without_extension . $file_extension; # Prepend the upper level output directory, the name and the extension to get to the real name.
            my $actual_output_nameonly     = $name_without_extension . $file_extension;

            log_this("INFO",$g_routine_name,($num_combined_files_created + 1) . " OUT_OF " . $actual_number_of_granules_to_process . " PROCESSING_GRANULE $when_processed_parameter $from_mixed_file $i_sst_filename $i_sst4_filename $i_oc_filename $actual_output_fullfilename");

            $log_message = "COMBINED_FILE_START ". $i_out_filename . " " . $actual_output_fullfilename; 
            log_this("INFO",$g_routine_name,$log_message);

            #------------------------------------------------------------------------------------------------
            # DISTINCT_STAGE 4: Combining
            #------------------------------------------------------------------------------------------------
            #
            # At this point, we should have all we need to do the combining.
            # Call IDL to perform the combine operation.

            if ($skip_idl_execution == 0) {

                call_idl_to_perform_combine_operation($when_processed_parameter,
                                                    $i_sst_filename,
                                                    $i_sst4_filename,
                                                    $i_oc_filename,
                                                    $i_out_filename,
                                                    $sigevent_email_to,
                                                    $sigevent_clause,
                                                    $temp_dir,
                                                    $msg2report,
                                                    $sigevent_data);
            } else {

                $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
                $num_combined_files_created = $num_combined_files_created + 1; # Keep track of how many files we have combined.
                # Do clean up.  Remove the uncompressed files.
                unlink ($i_sst_filename);
                unlink ($i_sst4_filename);
                $log_message = "SKIPPING_IDL_EXECUTION $i_sst_filename $i_sst4_filename $i_oc_filename"; 
                log_this("INFO",$g_routine_name,$log_message);

                # If not running IDL, we manually set this flag to true to simulate that we have successfully created the combined file.
                $o_file_created_successfully_flag = 1;
                # TODO: Uncomment out next line.
                #next;
            }

            # Verify that the combined file is created successfully.

            ($o_file_created_successfully_flag,$o_actual_file_to_look,$o_output_file_name_wild_search) = verify_combined_file_is_created($name_only,
                                                                                                                                        $file_extension,
                                                                                                                                        $upper_level_output_directory);
            # Count the number of bytes created.

            if (($o_actual_file_to_look ne "") && (-e $o_actual_file_to_look)) {
                my $size_of_combined_file_in_bytes = (stat($o_actual_file_to_look))[7];
                $total_Bytes_created_files   += $size_of_combined_file_in_bytes
            }

            # If the test_only parameter from command line is true, remove the combined file and set the flag o_file_created_successfully_flag to 0 to simulate
            # the combine task failed.
            if ($test_only_flag eq "true") {
                $log_message="PERFORMING_TEST: Setting variable o_file_created_successfully_flag to 0 to simulate a failed combine task.";
                log_this("INFO",$g_routine_name,$log_message);
                $o_file_created_successfully_flag = 0;

                $log_message="PERFORMING_TEST: Removing combined file $o_actual_file_to_look to simulate a failed combine task";
                log_this("INFO",$g_routine_name,$log_message);
                unlink($o_actual_file_to_look);
            }

            # Move the just created file to its final location.
            # We use the value of i_processing_type together with the name to figure out where to place the file.

            move_combined_file_to_final_location($output_directory,
                                                $i_processing_type,
                                                $name_only,
                                                $o_actual_file_to_look,
                                                $o_output_file_name_wild_search,
                                                $sigevent_email_to,
                                                $sigevent_clause,
                                                $temp_dir,
                                                $msg2report);

            # Only increment the number of files created if it was indeed successfully or running our test.
            if (($o_file_created_successfully_flag == 1) || ($test_only_flag eq "true")) {
                $num_combined_files_created = $num_combined_files_created + 1; # Keep track of how many files we have combined.
            }

            my $time_stop_one_file_combining = time();
            my $time_spent_one_file_in_combining = $time_stop_one_file_combining - $time_start_one_file_combining;

            if ($use_pipe_flag) {
                # If using pipe for interprocess communication, write the combined file name and processing statistic to the pipe.
                write_child_pipe_for_interprocess_communication_historical($child_pipe,$scratch_area,
                                                                        $upper_level_output_directory,
                                                                        $i_processing_type,
                                                                        $name_without_extension,
                                                                        $file_extension,
                                                                        $time_start_one_file_combining,
                                                                        $time_stop_one_file_combining,
                                                                        $time_spent_one_file_in_combining,
                                                                        $NUM_FILES_TO_PROCESS,
                                                                        $num_sst_sst4_files,
                                                                        $loop_count,
                                                                        $number_of_loops_to_run,
                                                                        $num_files_read,
                                                                        $time_duration_uncompress,
                                                                        $total_Bytes_in_files);

            } else {
                # If not using pipe for interprocess communication (using an external file), write the combined file name and processing statistic to the external file.
                write_child_file_for_interprocess_communication_historical($scratch_area,
                                                                        $upper_level_output_directory,
                                                                        $i_processing_type,
                                                                        $name_without_extension,
                                                                        $file_extension,
                                                                        $time_start_one_file_combining,
                                                                        $time_stop_one_file_combining,
                                                                        $time_spent_one_file_in_combining,
                                                                        $NUM_FILES_TO_PROCESS,
                                                                        $num_sst_sst4_files,
                                                                        $loop_count,
                                                                        $number_of_loops_to_run,
                                                                        $num_files_read,
                                                                        $time_duration_uncompress,
                                                                        $total_Bytes_in_files);



            }
        } # end for loop_count

        # Reset back the names of the SST4 and LAC_OC so we can clean them up.
        $i_sst4_filename = $saved_sst4_filename;
        $i_oc_filename   = $i_oc_filename;


        #------------------------------------------------------------------------------------------------
        # DISTINCT_STAGE 5: Cleaning
        #------------------------------------------------------------------------------------------------
        #
        # Remove the SST working file if it exist and the combine was successful.  For SST4 and LAC_OC, we move them to holding tank
        # in case another version of the SST shows up later.

        clean_up ($o_file_created_successfully_flag,
                $i_sst_filename,
                $i_sst4_filename,
                $i_oc_filename,
                $scratch_area);

        # If running this as a child sub process we need to exit to signify that we are done with the combiner job.
        if ($child_pid == 0) {
            log_this("INFO",$g_routine_name,"MULTI_PROCESS_IN_CHILD_PROCESS_RUNNING_END " . $working_on_this_file);
            if ($use_pipe_flag) {
                if (defined $child_pipe) {
                    if ($g_debug) {
                        log_this("INFO",$g_routine_name,"CHILD_PIPE_CLOSE " . $working_on_this_file);
                    }
                    $child_pipe->close;
                }
            }
            exit(0); # Because this part of the code is run in a subprocess, we need to exit here to signify that we are done with the combiner job.
        } else {
            # PARENT_PROCESS: Do some house keeping to keep the indices in check.
            log_this("INFO",$g_routine_name,"MULTI_PROCESS_IN_PARENT_PROCESS_RUNNING_END " . $working_on_this_file); 
            $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
        }

    } else {
        # PARENT_PROCESS: Do some house keeping to keep the indices in check.
        # Note that if doing parallel processing, the jobs are farmed out by the subprocesses and it is difficult to keep track of how long the combining
        # take so we cannot use a timer here.

        log_this("INFO",$g_routine_name,"MULTI_PROCESS_IN_PARENT_PROCESS " . $working_on_this_file); 
        $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
        $num_combined_files_created = $num_combined_files_created + 1; # Keep track of how many files we have combined.
        $num_subprocesses_started = $num_subprocesses_started + 1;     # We assume that the sub process has been started for each loop.
        $child_pid = $DUMMY_PROCESS_ID;  # Set this child process id to something we don't normally expect to represent running the parent process.
    }
}    # End while loop

# PARENT_PROCESS: Wait for all the sub processes to finish here if we had started any.
my $time_start_waiting = time();
log_this("INFO",$g_routine_name,"MULTI_PROCESS_BEGIN_WAITING_FOR_CHILD NUM_SUBPROCESSES_STARTED $num_subprocesses_started");
if ($num_subprocesses_started > 0) {
    my $sub_process_index = 0;
    do {
        $kid = waitpid(-1, WNOHANG);
        if ($g_debug) {
            log_this("INFO",$g_routine_name,"MULTI_PROCESS_WAITING_FOR_CHILD_END KID $kid");
        }
    } while $kid > 0;
}

my $time_end_waiting = time();
my $combine_stage_end = time();
my $combine_stage_duration = $combine_stage_end - $combine_stage_start;

# Do some house keeping from the parent process so we know how many files and total of bytes processed.
# Mainly used by developer for testing to allow the turning on or off of the house keeping portion of the code.

my $do_main_process_house_keeping_flag = 1;  # Normally, set to 1 for OPS mode.

if ($do_main_process_house_keeping_flag and $use_parallel_processing_flag) {
    do "$GHRSST_PERL_LIB_DIRECTORY/modis_level2_main_process_house_keeping_historical.pl";

    my $time_start_house_keeping = time();

    my $code_portion = "HOUSE_KEEPING:";
    my $print_debug  = 0;

    my %o_run_log_for_interprocess_communication_historical;  # Hash table containing as key the combined file and as values the processing statistics.
    my $run_log_array_ref;
    my $o_run_log_for_interprocess_communication_historical_ref;

    if ($use_pipe_flag) {
        # We need to close the child_pipe to flush all output so the reading below from the master_pipe won't be blocked forever.
        if (defined($child_pipe)) {
            if ($print_debug) {
                log_this("INFO",$code_portion,"CHILD_PIPE_CLOSE");
            }
            $child_pipe->close;
        }

        # If using the pipe, read from the pipe to get an array of string representing the processing statistics.

        $run_log_array_ref = read_master_pipe_for_interprocess_communication_historical($master_pipe);
    } else {
        # If not using pipe but external file, read from the external file to get an array of string representing the processing statistics.

        $run_log_array_ref = read_master_file_for_interprocess_communication_historical($scratch_area,$i_processing_type);
    }

    # We now have the array of strings, convert them into a hash table.

    $o_run_log_for_interprocess_communication_historical_ref = convert_run_log_for_interprocess_communication_historical($run_log_array_ref);
    %o_run_log_for_interprocess_communication_historical = %$o_run_log_for_interprocess_communication_historical_ref;  # Derefence the hash reference.

    if ($print_debug) {
        my $hash_size = keys %o_run_log_for_interprocess_communication_historical;
        log_this("INFO",$code_portion,"INTERPROCESS_COMMUNICATION HASH_SIZE $hash_size");
    }

    my ($o_num_combined_files_created, $o_num_files_read, $o_total_time_combining_jobs, $o_total_Bytes_created_files, $o_total_time_stage_files, $o_total_bytes_in_file) = modis_level2_main_process_house_keeping_historical(\%o_run_log_for_interprocess_communication_historical);

    my $time_stop_house_keeping = time();
    my $seconds_spent_house_keeping = $time_stop_house_keeping - $time_start_house_keeping;
    log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_house_keeping $seconds_spent_house_keeping NUM_COMBINED_FILES_CREATED $o_num_combined_files_created NUM_FILES_TO_PROCESS $NUM_FILES_TO_PROCESS NUM_FILES_READ $o_num_files_read TOTAL_BYTES_CREATED $o_total_Bytes_created_files TOTAL_TIME_STAGE_FILES_IF_SEQUENTIAL $o_total_time_stage_files TOTAL_TIME_COMBINING_JOBS_IF_SEQUENTIAL $o_total_time_combining_jobs");
    # Set these variables to the main process will have them.
    $num_files_read = $o_num_files_read;
    $num_combined_files_created = $o_num_combined_files_created;

    # Save some statistics about total sizes of file read and created.
    $total_Bytes_created_files = $o_total_Bytes_created_files;
    $total_Bytes_in_files      = $o_total_bytes_in_file;
    $time_spent_in_uncompressing = $o_total_time_stage_files;
}

if ($num_combined_files_created > 0) {
     my $combine_stage_average  = $combine_stage_duration / $num_combined_files_created;
     my $combine_stage_average_str = sprintf("%.2f",$combine_stage_average);
    log_this("INFO",$g_routine_name,"MULTI_PROCESS_END_WAITING_FOR_CHILD NUM_SUBPROCESSES_STARTED $num_subprocesses_started NUM_COMBINED_FILES_CREATED $num_combined_files_created" . " WAITED_IN_SECONDS " . ($time_end_waiting - $time_start_waiting) . " COMBINE_STAGE_DURATION " . $combine_stage_duration . " COMBINE_STAGE_AVERAGE " . $combine_stage_average_str);
} else {
    log_this("INFO",$g_routine_name,"MULTI_PROCESS_END_WAITING_FOR_CHILD NUM_SUBPROCESSES_STARTED $num_subprocesses_started NUM_COMBINED_FILES_CREATED $num_combined_files_created " . " WAITED_IN_SECONDS " . ($time_end_waiting - $time_start_waiting) . " COMBINE_STAGE_DURATION " . $combine_stage_duration);
}

my $program_time_end = time();
my $elapsed_in_seconds = $program_time_end - $program_time_start;

# If doing parallel processing, use the elapsed_in_seconds for the combining time.
if ($use_parallel_processing_flag) {
    $time_spent_in_combining = $elapsed_in_seconds;
} else {
    $time_spent_in_combining = $combine_stage_duration;
}
my $elapsed_in_minutes = sprintf("%.2f",($elapsed_in_seconds/60.0));

# ---------- Close up shop ----------

#
# Variables related to disk space calculation.
#

my $Kilobyte_to_Byte_conversion_factor     = 1024;       # Kilobyte_const in Bytes
my $Megabyte_to_Byte_conversion_factor     = 1048576;    # Megabyte_const in Bytes
my $Gigabyte_to_Byte_conversion_factor     = 1073741824; # in Bytes
my $Gigabyte_to_Megabyte_conversion_factor = 1024;       # in Megabyte

my $total_Megabytes_in_files = $total_Bytes_in_files / $Megabyte_to_Byte_conversion_factor;
my $total_Gigabytes_in_files = $total_Bytes_in_files / $Gigabyte_to_Byte_conversion_factor;

# Print run statistics.

log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_crawling         $time_spent_in_crawling");
log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_uncompress_move  $time_spent_in_uncompressing");
log_this("INFO",$g_routine_name,"TIME_STAT Seconds_spent_in_combining        $time_spent_in_combining");
log_this("INFO",$g_routine_name,"FILES_STAT Number_of_files_read             $num_files_read");
log_this("INFO",$g_routine_name,"FILES_STAT Batch_size                       $NUM_FILES_TO_PROCESS");
log_this("INFO",$g_routine_name,"FILES_STAT Number_of_combined_files_created $num_combined_files_created");
log_this("INFO",$g_routine_name,"FILES_STAT total_Bytes_in_files             $total_Bytes_in_files");
log_this("INFO",$g_routine_name,"FILES_STAT total_Megabytes_in_files         $total_Megabytes_in_files");
log_this("INFO",$g_routine_name,"FILES_STAT total_Gigabytes_in_files         $total_Gigabytes_in_files");

my $total_Megabytes_created = $total_Bytes_created_files / $Megabyte_to_Byte_conversion_factor;
my $total_Gigabytes_created = $total_Bytes_created_files / $Gigabyte_to_Byte_conversion_factor;

log_this("INFO",$g_routine_name,"FILES_STAT total_Bytes_created_files $total_Bytes_created_files");
log_this("INFO",$g_routine_name,"FILES_STAT total_Megabytes_created   $total_Megabytes_created");
log_this("INFO",$g_routine_name,"FILES_STAT total_Gigabytes_created   $total_Gigabytes_created");

if ($num_combined_files_created > 0) {
    my $average_processing_time = $elapsed_in_seconds / $num_combined_files_created;
    my $average_processing_time_str = sprintf("%.2f",$average_processing_time);
    log_this("INFO",$g_routine_name,"TIME_STAT Seconds_Average_Processing $average_processing_time_str");
}

log_this("INFO",$g_routine_name,"TIME_STAT Seconds_Elapsed           $elapsed_in_seconds");
log_this("INFO",$g_routine_name,"TIME_STAT Minutes_Elapsed           $elapsed_in_minutes");

my $end_processing_time = localtime;

log_this("INFO",$g_routine_name,"BEGIN_PROCESSING_TIME $begin_processing_time");
log_this("INFO",$g_routine_name,"END_PROCESSING_TIME   $end_processing_time");

if ($g_debug) {
    $sigevent_type = "information";
    $sigevent_msg = "MODIS Level 2 Combiner ended.";
    $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
    ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
}

my $job_delete_status = delete_job($g_routine_name,$i_processing_type,$job_name);

# End of main program here.
# Everything after this line are subroutines.

#------------------------------------------------------------------------------------------------------------------------
sub get_num_sst_count {
    my $sst_sst4_filelist_ref = shift;
    my @sst_sst4_filelist = @$sst_sst4_filelist_ref;
    my $o_num_sst_count = 0;
    my $total_num_files = scalar(@sst_sst4_filelist);
    my $index_to_list = 0;
    while ($index_to_list < $total_num_files) {
        my $working_on_this_file = $sst_sst4_filelist[$index_to_list];
        chomp($working_on_this_file);  # Remove the carriage return.
        # Only count the SST.nc file.
        if (index($working_on_this_file, "SST.nc") >= 0) {
            $o_num_sst_count = $o_num_sst_count + 1;
        }
        $index_to_list = $index_to_list + 1;
   }
   return($o_num_sst_count);
}

#------------------------------------------------------------------------------------------------------------------------
sub get_matching_sst4_filename_historical {
    # Function returns a matching SST4 file name if it exist and "DUMMY_SST4_FILENAME" if it does not.
    #
    # Given this:
    #
    #     /data/dev/scratch/qchau/data/netcdf_files_from_obpg/aqua/2015/215/A2015215195500.L2_LAC_SST.nc
    #
    # Return this:
    #
    #     /data/dev/scratch/qchau/data/netcdf_files_from_obpg/aqua/2015/215/A2015215195500.L2_LAC_SST4.nc

    my $sst_filename_compressed_file = shift;

    my $find         = "SST.nc";                               # Look for this string.
    my $replace_with = "SST4.nc";                              # Replace with this string.
    $find            = quotemeta $find;                        # Escape regex metachars if present.
    $sst_filename_compressed_file =~ s/$find/$replace_with/g;  # Do the replacement of SST.nc to SST4.nc

    my $o_sst4_filename_compressed_file = $sst_filename_compressed_file; # Get the SST4.nc name.

    # If the SST4.nc file does not exist, return "DUMMY_SST4_FILENAME" otherwise return the good name.
    if (not (-e $o_sst4_filename_compressed_file)) {
        $o_sst4_filename_compressed_file = "DUMMY_SST4_FILENAME";
    }

    return($o_sst4_filename_compressed_file);
}

#------------------------------------------------------------------------------------------------------------------------
sub stage_input_files_for_combiner_historical {

    my $index_to_sst_sst4_list            = shift;
    my $sst_sst4_filelist_ref             = shift;
    my $filtered_sst_sst4_names_without_md5_files_ref = shift;
    my $total_Bytes_in_files              = shift;
    my $i_num_files_read                  = shift;
    my $i_processing_type                 = shift;
    my $perform_move_instead_of_copy_flag = shift;
    my $num_combined_files_created        = shift;
    my $num_sst_sst4_files                = shift;
    my $scratch_area                      = shift;

    # Get any required references.

    my @sst_sst4_filelist = @$sst_sst4_filelist_ref;
    my @filtered_sst_sst4_names_without_md5_files = @$filtered_sst_sst4_names_without_md5_files_ref;

    # Output variables.

    my $o_status                = 0;
    my $o_num_files_read        = $i_num_files_read;
    my $o_total_Bytes_in_files  = $total_Bytes_in_files; 
    my $o_sst_filename          = "";
    my $o_sst4_filename         = "";
    my $o_oc_filename           = "";

    # Fetch 2 consecutive names from sst_sst4_filelist.  The first name will be the SST file and the 2nd name will be the SST4 file.

    my $sst_filename_compressed_file  = $sst_sst4_filelist[$index_to_sst_sst4_list];
    chomp ($sst_filename_compressed_file);
    my $sst4_filename_compressed_file = get_matching_sst4_filename_historical($sst_filename_compressed_file);
    
    # Remove the carriage return

    chomp ($sst4_filename_compressed_file);
    
    #
    # Get the sizes of these 2 files.
    #
    
    if (-e $sst_filename_compressed_file) {
        my $size_of_sst_file_in_bytes  = (stat($sst_filename_compressed_file))[7];
        $o_total_Bytes_in_files += $size_of_sst_file_in_bytes; 
        $o_num_files_read += 1; 
    }
    
    # Sometimes, the name of the SST4 is not a real name especially if the SST is a Day file.  We do a check for valid file before getting the file size.
    if (-e $sst4_filename_compressed_file) {
        my $size_of_sst4_file_in_bytes = (stat($sst4_filename_compressed_file))[7];
        $o_total_Bytes_in_files += $size_of_sst4_file_in_bytes;
        $o_num_files_read += 1; 
    }
    
    # Set the scratch area for decompression to the same directory as the compressed file so the move later won't be costly.

    my $decompress_to_directory =  $scratch_area;

    # Uncompressed the 2 files if they are compressed.  If not, just do a move to scratch area if the user wishes.
    # Note: This script only works on uncompressed file.  The function perform_decompression_task_historical will always perform a copy or move.

    # Status returned: 0 good, 1 bad.

    my ($status,$i_sst_filename)  = perform_decompression_task_historical("SST",$sst_filename_compressed_file,$i_processing_type,$decompress_to_directory,$perform_move_instead_of_copy_flag,$num_combined_files_created,$num_sst_sst4_files);
    # Set the name so we can return it.
    $o_sst_filename = $i_sst_filename;

    if ($status == 1) {  # If cannot decompressed, move on to the next pair.
        $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
        log_this("WARN",$g_routine_name,"File $sst_filename_compressed_file not found.  It may be worked on by another run instance of this script.");
        $o_status = 1;
        return ($o_status,
                $o_num_files_read,
                $o_total_Bytes_in_files,
                $o_sst_filename,
                $o_sst4_filename,
                $o_oc_filename);

    }
    
    my ($status,$i_sst4_filename) = perform_decompression_task_historical("SST4",$sst4_filename_compressed_file,$i_processing_type,$decompress_to_directory,$perform_move_instead_of_copy_flag,$num_combined_files_created,$num_sst_sst4_files);
    # Set the name so we can return it.
    $o_sst4_filename = $i_sst4_filename;

    if ($status == 1) { # If cannot decompressed, move on to the next pair.
        $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
        log_this("WARN",$g_routine_name,"File $sst4_filename_compressed_file not found. It may be worked on by another run instance of this script.");
        # New logic: If the SST4 file cannot be copied we print a WARN message only and set it to dummy.
        $o_sst4_filename = "DUMMY_SST4_FILENAME";
        $sigevent_type = "error";
        $sigevent_msg = "Cannot stage file $sst4_filename_compressed_file TO $scratch_area";
        $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
        ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
    }
    
    # Get the LAC_OC file name as well if it exists.  This file will be combined with the SST if the SST is a Day file.

    my $i_oc_filename   = "DUMMY_OC_FILENAME";  # Replace this variable with the real name if it is found.

    $o_oc_filename = $i_oc_filename;            # Set to default name.

    my ($oc_name_in_list_flag,$o_index_found_to_sst4_filenames,$o_actual_oc_filename)   = is_oc_name_in_list($sst_filename_compressed_file,\@filtered_sst_sst4_names_without_md5_files);
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"oc_name_in_list_flag [$oc_name_in_list_flag]");
	log_this("DEBUG",$g_routine_name,"o_index_found_to_sst4_filenames[$o_index_found_to_sst4_filenames]");
    }

    if ($oc_name_in_list_flag == 1) {
        # Get the LAC_OC name if found it.
        $i_oc_filename = $filtered_sst_sst4_names_without_md5_files[$o_index_found_to_sst4_filenames];
        chomp($i_oc_filename);
    }

    # If a valid name returned, we use it to set  
    if ($o_actual_oc_filename ne '') {
        $oc_name_in_list_flag = 1;
        $i_oc_filename = $o_actual_oc_filename;
        $o_oc_filename = $o_actual_oc_filename;
    }

    # If an LAC_OC file does not exist in the expected place, we look it in the holding tank.
    # Remember that the holding tank is a place where SST4 and LAC_OC files are placed there after
    # they have been combined with the SST.  We keep them there in case a new version of the SST
    # is available so they can be combined again.
    
    if (($i_oc_filename eq "DUMMY_OC_FILENAME") or ($oc_name_in_list_flag == 0)) {
        my ($r_matching_sst4_name,$r_matching_oc_name) = get_names_from_holding_tank($i_sst_filename,$scratch_area);
        # If the named of the LAC_OC returned is not empty, we save it.
        if ($r_matching_oc_name ne "") {
            $i_oc_filename = $r_matching_oc_name;
            $o_oc_filename = $i_oc_filename;
        }
    }

    if ($debug_flag) {
        log_this("DEBUG",$g_routine_name,"i_oc_filename [$i_oc_filename]");
        log_this("DEBUG",$g_routine_name,"oc_name_in_list_flag [$oc_name_in_list_flag]");
    }
    #log_this("DEBUG",$g_routine_name,"early#exit#098");
    #exit(0);
    
    # Uncompress the LAC_OC file to scratch disk to get ready for combining.

    if ($i_oc_filename ne "DUMMY_OC_FILENAME") {
        my $status = 0;  # Becareful not to re-define i_oc_filename as local to this if block since it means a different variable.
        my $original_oc_filename = $i_oc_filename;  # Save this file name so we can report it if something goes well.
        ($status,$i_oc_filename)  = perform_decompression_task_historical("OC",$i_oc_filename,$i_processing_type,$decompress_to_directory,$perform_move_instead_of_copy_flag,$num_combined_files_created,$num_sst_sst4_files);
        $o_oc_filename = $i_oc_filename;
        if ($status == 1) {
            $index_to_sst_sst4_list     = $index_to_sst_sst4_list + 1;
            log_this("WARN",$g_routine_name,"File $original_oc_filename not found.  It may be worked on by another run instance of this script.");
            # New logic: If the OC file cannot be copied we print a WARN message only and set it to dummy and keep going.
            $o_oc_filename = "DUMMY_OC_FILENAME";
            $sigevent_type = "error";
            $sigevent_msg = "Cannot stage file $original_oc_filename TO $scratch_area";
            $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
            ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
        }

        $o_num_files_read += 1;  # We've just read another file.

        # Let's count of the size of the LAC_OC file so we can keep track of how much we have read.

        if (-e $i_oc_filename) {
            my $size_of_oc_file_in_bytes = (stat($i_oc_filename))[7];
            $o_total_Bytes_in_files += $size_of_oc_file_in_bytes;
        }
    }
    log_this("DEBUG",$g_routine_name,"i_oc_filename [$i_oc_filename]");
    log_this("DEBUG",$g_routine_name,"oc_name_in_list_flag [$oc_name_in_list_flag]");
    #log_this("DEBUG",$g_routine_name,"early#exit#098");
    #exit(0);


    return ($o_status,
            $o_num_files_read,
            $o_total_Bytes_in_files,
            $o_sst_filename,
            $o_sst4_filename,
            $o_oc_filename);
}

sub create_stage_input_filenames {

    my $index_to_sst_sst4_list            = shift;
    my $sst_sst4_filelist_ref             = shift;
    my $filtered_sst_sst4_names_without_md5_files_ref = shift;
    my $total_Bytes_in_files              = shift;
    my $i_num_files_read                  = shift;
    my $i_processing_type                 = shift;
    my $perform_move_instead_of_copy_flag = shift;
    my $num_combined_files_created        = shift;
    my $num_sst_sst4_files                = shift;
    my $scratch_area                      = shift;

    my $g_routine_name = "modis_level2_combiner_historical:create_stage_input_filenames:";

    # Get any required references.

    my @sst_sst4_filelist = @$sst_sst4_filelist_ref;
    my @filtered_sst_sst4_names_without_md5_files = @$filtered_sst_sst4_names_without_md5_files_ref;

    # Output variables.

    my $o_status                = 0;
    my $o_sst_filename          = "";
    my $o_sst4_filename         = "DUMMY_SST4_FILENAME";
    my $o_oc_filename           = "";

    # Fetch 2 consecutive names from sst_sst4_filelist.  The first name will be the SST file and the 2nd name will be the SST4 file.

    my $sst_filename_compressed_file  = $sst_sst4_filelist[$index_to_sst_sst4_list];
    chomp ($sst_filename_compressed_file);
    my $sst4_filename_compressed_file = get_matching_sst4_filename_historical($sst_filename_compressed_file);
    my $i_sst_filename                = $sst_filename_compressed_file;
    
    # Remove the carriage return

    chomp ($sst4_filename_compressed_file);
    if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"sst4_filename_compressed_file [$sst4_filename_compressed_file]");
    }
    
    # Set the name so we can return it.
    $o_sst_filename = $i_sst_filename;
    $o_sst4_filename = $sst4_filename_compressed_file;

    # Get the LAC_OC file name as well if it exists.  This file will be combined with the SST if the SST is a Day file.

    my $i_oc_filename   = "DUMMY_OC_FILENAME";  # Replace this variable with the real name if it is found.

    $o_oc_filename = $i_oc_filename;            # Set to default name.

    my ($oc_name_in_list_flag,$o_index_found_to_sst4_filenames,$o_actual_oc_filename)   = is_oc_name_in_list($i_sst_filename,\@filtered_sst_sst4_names_without_md5_files);
    if ($debug_flag) {
        log_this("DEBUG",$g_routine_name,"i_sst_filename [$i_sst_filename]");
        log_this("DEBUG",$g_routine_name,"oc_name_in_list_flag [$oc_name_in_list_flag] o_actual_oc_filename [$o_actual_oc_filename]");
        log_this("DEBUG",$g_routine_name,"o_index_found_to_sst4_filenames[$o_index_found_to_sst4_filenames]");
    }

    if ($oc_name_in_list_flag == 1) {
        # Get the LAC_OC name if found it.
        $i_oc_filename = $filtered_sst_sst4_names_without_md5_files[$o_index_found_to_sst4_filenames];
        chomp($i_oc_filename);
    }

    # If a valid name returned, we use it to set  
    if ($o_actual_oc_filename ne '') {
        $oc_name_in_list_flag = 1;
        $i_oc_filename = $o_actual_oc_filename;
        $o_oc_filename = $o_actual_oc_filename;
    }

    # If an LAC_OC file does not exist in the expected place, we look it in the holding tank.
    # Remember that the holding tank is a place where SST4 and LAC_OC files are placed there after
    # they have been combined with the SST.  We keep them there in case a new version of the SST
    # is available so they can be combined again.
    
    if (($i_oc_filename eq "DUMMY_OC_FILENAME") or ($oc_name_in_list_flag == 0)) {
        my ($r_matching_sst4_name,$r_matching_oc_name) = get_names_from_holding_tank($i_sst_filename,$scratch_area);
        # If the named of the LAC_OC returned is not empty, we save it.
        if ($r_matching_oc_name ne "") {
            $i_oc_filename = $r_matching_oc_name;
            $o_oc_filename = $i_oc_filename;
        }
    }

    if ($debug_flag) {
        log_this("DEBUG",$g_routine_name,"i_oc_filename [$i_oc_filename]");
        log_this("DEBUG",$g_routine_name,"oc_name_in_list_flag [$oc_name_in_list_flag]");
    }
    #log_this("DEBUG",$g_routine_name,"early#exit#098");
    #exit(0);
    
    # Uncompress the LAC_OC file to scratch disk to get ready for combining.

    if ($i_oc_filename ne "DUMMY_OC_FILENAME") {
        my $status = 0;  # Becareful not to re-define i_oc_filename as local to this if block since it means a different variable.
        my $original_oc_filename = $i_oc_filename;  # Save this file name so we can report it if something goes well.
        #($status,$i_oc_filename)  = perform_decompression_task_historical("OC",$i_oc_filename,$i_processing_type,$decompress_to_directory,$perform_move_instead_of_copy_flag,$num_combined_files_created,$num_sst_sst4_files);
        $o_oc_filename = $i_oc_filename;
    }
    if ($debug_flag) {
        log_this("DEBUG",$g_routine_name,"i_oc_filename [$i_oc_filename]");
        log_this("DEBUG",$g_routine_name,"oc_name_in_list_flag [$oc_name_in_list_flag]");
    }
    return ($o_status,
            $o_sst_filename,
            $o_sst4_filename,
            $o_oc_filename);
}

#------------------------------------------------------------------------------------------------------------------------
sub verify_combined_file_is_created {
    # If a file was created successfuly, we should be able to find the name in the expected output directory with the name "*.LAC*"

    my $i_name_only                    = shift;
    my $i_file_extension               = shift;
    my $i_upper_level_output_directory = shift;

    my $o_actual_file_to_look            = "";
    my $o_file_created_successfully_flag = 0; # Set to one if found one output file.
    my $o_output_file_name_wild_search   = ""; 

    # Because the output file actually created is something like:
    #
    #     A2012234150500.LAC_GSSTN
    #
    # and our variable i_out_filename is something like
    #
    #     A2012234150500.L2_LAC_SST
    #
    # we have to do a search to look for any file with the name A2012234150500.LAC*

    # Do a sanity check on the name of the file for 2019 OBPG naming pattern.
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"#0007:VARIABLE_CHECK:i_name_only[$i_name_only]");
    }
    my $name_without_extension = "DUMMY_NAME_WITHOUT_EXTENSION" ;
    my $pos_of_dot = -1;
    if (index($i_name_only,"L2.SST.nc") >= 0) {
        # Get the name without extension.   # AQUA_MODIS.2019289042500.L2.SST.nc  # AQUA_MODIS.2019289042500.L2.SST.nc
        $pos_of_dot = index($i_name_only,".nc");
        $name_without_extension = $i_name_only;
        if ($pos_of_dot > 0) {
            # Do one final check to see if the value of i_name_only is AQUA_MODIS.2019289042500.L2.SST.nc.
            # The actual output file is A2019289042500.LAC_GSSTN.nc so we fetch the first character, plus the 
            my $pos_first_dot = index($i_name_only,".");
            my $pos_second_dot = index($i_name_only,".",$pos_first_dot+1);
            $name_without_extension = substr($i_name_only,0,1) . substr($i_name_only,$pos_first_dot+1,$pos_second_dot-$pos_first_dot-1);
	    if ($debug_flag) {
		log_this("DEBUG",$g_routine_name,"#0006:VARIABLE_CHECK:pos_first_dot[$pos_first_dot]");
		log_this("DEBUG",$g_routine_name,"#0006:VARIABLE_CHECK:pos_second_dot[$pos_second_dot]");
	    }
        }
	if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"#0006:VARIABLE_CHECK:i_name_only[$i_name_only]");
	    log_this("DEBUG",$g_routine_name,"#0006:VARIABLE_CHECK:pos_of_dot[$pos_of_dot]");
	    log_this("DEBUG",$g_routine_name,"#0006:VARIABLE_CHECK:name_without_extension[$name_without_extension]");
	}

    } else {
    # Get the name without extension.
    $pos_of_dot = index($i_name_only,".");
    $name_without_extension = $i_name_only;
    if ($pos_of_dot > 0) {
        $name_without_extension = substr($i_name_only,0,$pos_of_dot);
    }
    }

    # Becareful to add "*" at the end of the search string to get the correct result.
    # Without the "*", the glob function was falsely return the file name.

    $o_output_file_name_wild_search = $i_upper_level_output_directory . "/" . $name_without_extension . $i_file_extension . "*";

    my @file_list = glob($o_output_file_name_wild_search);

    my $num_names_found = scalar(@file_list);

    # If there was at least one name, we get the first one.

    if ($num_names_found >= 1) {
        $o_actual_file_to_look = $file_list[0];
        $o_file_created_successfully_flag = 1;
    }

    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:i_name_only[$i_name_only]");
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:i_upper_level_output_directory[$i_upper_level_output_directory]");
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:name_without_extension[$name_without_extension]");
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:i_file_extension[$i_file_extension]");
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:o_output_file_name_wild_search [$o_output_file_name_wild_search]");
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:num_names_found[$num_names_found]");
	log_this("DEBUG",$g_routine_name,"#0005:VARIABLE_CHECK:o_actual_file_to_look [$o_actual_file_to_look]");
    }
    #log_this("DEBUG",$g_routine_name,"#0005:early#exit#0099");
    #exit;

    return ($o_file_created_successfully_flag,$o_actual_file_to_look,$o_output_file_name_wild_search);
}
#------------------------------------------------------------------------------------------------------------------------
sub call_idl_to_perform_combine_operation {
    # Calls IDL to perform the combine operation.

    my $i_when_processed_parameter = shift;
    my $i_sst_filename    = shift;
    my $i_sst4_filename   = shift;
    my $i_oc_filename     = shift;
    my $i_out_filename    = shift;
    my $sigevent_email_to = shift;
    my $sigevent_clause   = shift;
    my $temp_dir          = shift;
    my $msg2report        = shift;
    my $sigevent_data     = shift;

    my $idl_argument_strings    = "";
    my $rt_flag                 = "";
    my $call_system_command_str = "";

    $idl_argument_strings = "-args \"$i_sst_filename\" \"$i_sst4_filename\" \"$i_oc_filename\" \"$i_out_filename\" \"$i_when_processed_parameter\" ";

    #
    # Create the argument lists to system command.
    #

    my @args = ("/usr/local/bin/idl");

    #
    # Make the system call with arguments from idl_argument_strings variable.
    #

    # Call the appropriate IDL program to combine the files depends on the file extension.
    # We can also check GHRSST_PROCESSING_NETCDF_FILE environmental variable if the name does not have .nc as the case with the test files.

    if ((index($i_sst_filename,".nc") >= 0) || ($ENV{GHRSST_PROCESSING_NETCDF_FILE} eq "true")) {
        if ($ENV{GHRSST_MODIS_L2_COMBINER_USE_NETCDF_COMBINER_TO_HDF} eq "true") {
            $rt_flag = "-quiet -rt=$GHRSST_IDL_LIB_DIRECTORY/combine_netcdf_sst_and_sst4_files.sav";
            log_this("INFO",$g_routine_name,"USING_NETCDF_TO_HDF_VERSION_OF_THE_COMBINER");
        } else {
            $rt_flag = "-quiet -rt=$GHRSST_IDL_LIB_DIRECTORY/combine_netcdf_sst_and_sst4_files_to_netcdf.sav";
            if ($g_debug) {
                log_this("INFO",$g_routine_name,"USING_NETCDF_TO_NETCDF_VERSION_OF_THE_COMBINER");
            }
        }
    } else {
        $rt_flag = "-quiet -rt=$GHRSST_IDL_LIB_DIRECTORY/combine_sst_and_sst4_files.sav";
        if ($g_debug) {
            log_this("INFO",$g_routine_name,"USING_HDF_VERSION_OF_THE_COMBINER");
        }
    }
    $call_system_command_str = "$args[0] $rt_flag $idl_argument_strings ";

    if ($g_debug) { log_this("DEBUG",$g_routine_name,"SYSTEM_COMMAND $call_system_command_str"); }

    #print, "call_system_command_str $call_system_command_str\n";
    #print, "early#exit#0002\n";
    #log_this("INFO",$g_routine_name,"call_system_command_str $call_system_command_str");
    #log_this("INFO",$g_routine_name,"early#exit#0002");
    #exit;


    my $exit_code = system("$call_system_command_str");

    #
    # Check for errors.
    #

    if ($? == -1) {
#log_this("INFO",$g_routine_name,"Status from [$call_system_command_str] is [" . $? . "]");
        print "modis_level2_combiner:ERROR: [$call_system_command_str] failed to execute: $?\n";
        $o_status = 1;
        $sigevent_type = "error";
        $sigevent_msg = "Something went wrong with executing [$call_system_command_str]";
        log_this("ERROR",$g_routine_name,$sigevent_msg);
        ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
        exit(1);
    } elsif ($? == 256){
#log_this("INFO",$g_routine_name,"Status from [$call_system_command_str] is [" . $? . "]");
        print "modis_level2_combiner:ERROR: Cannot find file $GHRSST_IDL_LIB_DIRECTORY/combine_sst_and_sst4_files.sav \n";
        $sigevent_type = "error";
        $sigevent_msg = "Something went wrong with executing [$call_system_command_str]";
        $o_status = 1;
        exit(1);
    } elsif ($? == 0){
#log_this("INFO",$g_routine_name,"Status from [$call_system_command_str] is [" . $? . "]");
#            print "modis_level2_combiner: system $args[0] < $args[1] executed with: $?\n";
#            print "modis_level2_combiner: Everything is OK.\n";
        $o_status = 0;
    } else {
#log_this("INFO",$g_routine_name,"Status from [$call_system_command_str] is [" . $? . "]");
      $exit_code = $exit_code >> 8;
      if ($exit_code != 0)  {
        log_this("ERROR",$g_routine_name,"SYSTEM_CODE=" . $?);
        log_this("ERROR",$g_routine_name,"exit_code=" . $exit_code);
        $sigevent_type = "error";
        $sigevent_msg = "IDL or combiner code may be not be available.  Something went wrong with executing [$call_system_command_str]";
        #print "modis_level2_combiner:ERROR: system [$call_system_command_str] executed with: $?\n";
        log_this("ERROR",$g_routine_name,$sigevent_msg);

        # We suspect that there is issue with IDL so we will use Perl to raise a sigevent.

        my $sigevent_provider      = "JPL";
        my $sigevent_source        = "GHRSST-PROCESSING";
        my $sigevent_type          = "ERROR";
        my $sigevent_category      = 'GENERATE';
        my $sigevent_description   = $sigevent_msg;
        do "$GHRSST_PERL_LIB_DIRECTORY/raise_sigevent.pl";
        raise_sigevent($sigevent_url,$sigevent_provider,$sigevent_source,$sigevent_type,$sigevent_category,$sigevent_description,$sigevent_data);

        $o_status = 1;
      }
        # Don't exit.  Just allow the rest of the code to perform cleaning by moving "errant" files to quarantine directory.
        # exit(1);
    }
}

#------------------------------------------------------------------------------------------------------------------------
sub perform_decompression_task_historical {
    # If the name contains .bz2, we will apply the bunzip2 program to it.
    # If it does not, we will simply perform a mv command.  Even if the file is mounted on different devices, the move will be successful.

    # Get input.

    my $i_file_type                         = shift;
    my $i_compressed_filename               = shift;
    my $i_processing_type                   = shift;
    my $i_scratch_directory                 = shift;
    my $i_perform_move_instead_of_copy_flag = shift;
    my $i_num_files_created_so_far          = shift;
    my $i_num_granules_to_process           = shift;

    # Output variable(s).

    my $o_status = 0; # A value of 0 is good, 1 is bad.
    my $o_uncompressed_filename = "";

    # If the name is a dummy name, we merely returns the original name.
    if ($i_compressed_filename eq "DUMMY_SST4_FILENAME") { 
        $o_uncompressed_filename = $i_compressed_filename;
        return ($o_status,$o_uncompressed_filename);
    }

    # Remove the directory name by splitting the full name name using the '/' character and get just the name.

    my @splitted_tokens = split(/\//,$i_compressed_filename);
    my $num_tokens = @splitted_tokens;
    my $name_only = $splitted_tokens[$num_tokens-1];  # Get just the name. 

    # We must check for existence of the uncompressed file. The program bunzip2 will not allow an overwrite.
    my $name_without_bz_extension = $name_only; 
    my $file_is_compressed_flag = 0;
    if ((rindex($name_only,".bz2")) >= 0) {
        $name_without_bz_extension = substr($name_only,0,-4);  # Get everything up to and not include the .
        $file_is_compressed_flag = 1;
    }

    # Based on the processing type, we will figure where to either uncompress or move the file to.

    my $upper_level_output_directory = "$i_scratch_directory/$i_processing_type";

    # Create the directory if it does not exist yet.
    if (!(-e $upper_level_output_directory)) {
        my $status_mkdir = mkdir_with_error_handling($upper_level_output_directory);
        # The mkdir function returns true if successful and false if failed.
        # if ($status_mkdir == 0) { exit(0); }
    }

    $o_uncompressed_filename = "$upper_level_output_directory/$name_without_bz_extension";

    # If the file was compressed and the uncompressed version exist, we remove the uncompressed file first.
    if (($file_is_compressed_flag == 1) && (-e "$o_uncompressed_filename")) {
        print "perform_decompression_task_historical: Removing existing file [$o_uncompressed_filename]\n";
        unlink($o_uncompressed_filename);
    }

    # If running a test, tweak the file name so it cannot be found.
    if (($ENV{GHRSST_MODIS_L2_COMBINER_TEST_CANNOT_COPY_SST4} eq 'true') and ($i_file_type eq 'SST4')) {
        $i_compressed_filename = $i_compressed_filename . '_this_file_should_not_be_there';
    }

    # If running a test, tweak the file name so it cannot be found.
    if (($ENV{GHRSST_MODIS_L2_COMBINER_TEST_CANNOT_COPY_OC} eq 'true') and ($i_file_type eq 'OC')) {
        $i_compressed_filename = $i_compressed_filename . '_this_file_should_not_be_there';
    }

    if ($file_is_compressed_flag == 1)  {
        my $call_system_command_str = "cp $i_compressed_filename $upper_level_output_directory ; /usr/bin/bunzip2 $upper_level_output_directory/$name_only";
        system("$call_system_command_str");
        #
        # Check for errors.
        #
        if ($? == -1) {
            log_this("ERROR",$g_routine_name,"[$call_system_command_str] failed to execute: $?");
            $o_status = 1;
        } elsif ($? == 256){
            log_this("ERROR",$g_routine_name,"Cannot find file $i_compressed_filename to copy or uncompress file $upper_level_output_directory/$name_only");
            $o_status = 1;
        } elsif ($? == 0){
            $o_status = 0;
        } else {
            log_this("ERROR",$g_routine_name,"[$call_system_command_str] executed with: $?\n");
            $o_status = 1;
        }
    } else {
        # The file is not compressed, we will simply perform a move command if requested, otherwise do a copy.

        my $call_system_command_str = "";
        if ($i_perform_move_instead_of_copy_flag eq "yes") {
            if (-e $i_compressed_filename) {
                $call_system_command_str = "mv $i_compressed_filename $o_uncompressed_filename";
                log_this("INFO",$g_routine_name,"FILE_MOVE $i_compressed_filename $o_uncompressed_filename");
            } else {
               # Something is wrong, the file is not there not.
               $o_status = 1;
               log_this("ERROR",$g_routine_name,"Cannot find file [$i_compressed_filename] to move to [$o_uncompressed_filename]");
            }
        } else {
            if (-e $i_compressed_filename) {
                $call_system_command_str = "cp $i_compressed_filename $o_uncompressed_filename";
                log_this("INFO",$g_routine_name,"FILE_COPY $i_compressed_filename $o_uncompressed_filename");
            } else {
               # Something is wrong, the file is not there not.
               $o_status = 1;
               log_this("ERROR",$g_routine_name,"Cannot find file [$i_compressed_filename] to copy to [$o_uncompressed_filename]");
            }
        }

        # Only perform the copy or move if the file to be operated on is there.
        # Note that the value of o_status should be set to 0 if we verified that we can proceed with the copy or move action.
        # The value of call_system_command_str should be set to the correct system command.

        if ($o_status == 0) { 
          log_this("INFO",$g_routine_name,($i_num_files_created_so_far + 1) . " OUT_OF " . ($i_num_granules_to_process) . " PRESTAGE_GRANULE $i_file_type $i_compressed_filename TO $o_uncompressed_filename");
          if ($g_debug) { log_this("DEBUG",$g_routine_name,"$call_system_command_str"); }

          my $ok_to_stage_file_flag = 1;

          # If using a file locking mechanism, lock the file using nfs_lock_file() function with the semaphore with ".lck" appended to the file name.
          if ($g_use_file_locking_mechanism_flag) {
            $ok_to_stage_file_flag = nfs_lock_file_wrapper($i_compressed_filename);
          }

          if ($ok_to_stage_file_flag) {
            system("$call_system_command_str"); #  == 0 or die "perform_decompression_task_historical: $call_system_command_str failed: $?";

            #
            # Check for errors.
            #
            if ($? == -1) {
                log_this("ERROR",$g_routine_name,"[$call_system_command_str] failed to execute: $?");
                $o_status = 1;
            } elsif ($? == 256){
                log_this("ERROR",$g_routine_name,"Cannot find file $i_compressed_filename to copy or move to $o_uncompressed_filename");
                $o_status = 1;
            } elsif ($? == 0){
                $o_status = 0;
            } else {
                log_this("ERROR",$g_routine_name,"[$call_system_command_str] executed with: $?\n");
                $o_status = 1;
            }
          } else { # end if ($ok_to_stage_file_flag)
              $o_status = 1; # A value of 0 is good, 1 is bad.  We set to 1 since cannot acquire the lock.
          }

          # Unlock the file if the locking mechanism was used.
          if ($g_use_file_locking_mechanism_flag) {
              if (defined($g_the_lock)) {
                  nfs_unlock_file($g_the_lock,$g_semaphore_name);
              }
          }
        }
    }

    return ($o_status,$o_uncompressed_filename);
}

#------------------------------------------------------------------------------------------------------------------------
sub get_names_from_holding_tank {

    # Given a name to search and look in the holding tank for a corresponding SST4/OC files and return them.
    # An empty string returned signify nothing was found.

    my $i_sst_full_name_to_search  = shift;
    my $i_scratch_area             = shift;

    my $g_routine_name = 'get_names_from_holding_tank:';

    my $o_matching_sst4_name = "";
    my $o_matching_oc_name   = "";

    my $debug_module = "get_names_from_holding_tank:";
    my $debug_mode = 0;

    # Remove the directory name.
    chomp($i_sst_full_name_to_search);
    my @splitted_tokens = split(/\//,$i_sst_full_name_to_search);  # The slash has to be escaped.
    my $num_tokens = @splitted_tokens;
    my $name_to_search = $splitted_tokens[$num_tokens-1];          # Get just the name.   It is the last token.

    my $look_for = "SST";
    my $find_this_string = quotemeta $look_for;
    my $replace_with = "SST4";

    $name_to_search =~ s/$find_this_string/$replace_with/; # Replace SST with SST4.

    # Build the full name of the SST4 to search for.  If it exists in the holding tank, we are good and save the SST4 name in o_matching_sst4_name variable.
    my $full_sst4_name_to_search = $i_scratch_area . "/holding_tank/" . $name_to_search;
    if (-e $full_sst4_name_to_search ) {
        $o_matching_sst4_name = $full_sst4_name_to_search;
    }

    $look_for = "SST4";
    $find_this_string = quotemeta $look_for;
    $replace_with = "OC";
    $name_to_search =~ s/$find_this_string/$replace_with/; # Replace SST4 with OC 

    # Build the full name of the OC to search for.  If it exists in the holding tank, we are good and save the OC naem in o_matching_oc_name variable.
    my $full_oc_name_to_search = $i_scratch_area . "/holding_tank/" . $name_to_search;
    if (-e $full_oc_name_to_search) {
        $o_matching_oc_name = $full_oc_name_to_search;
    }

    # Look for old OC filename format as well.
    if ((index($i_sst_full_name_to_search,"L2.SST") >= 0) and (index($i_sst_full_name_to_search,"MODIS") >= 0)) {
        my @splitted_array = split(/\./,$i_sst_full_name_to_search);
        my $pos_of_T = index($splitted_array[1],"T");
        my $new_time_field = "";
        if ($pos_of_T >= 0) {
            $new_time_field = substr($splitted_array[1],0,$pos_of_T) . substr($splitted_array[1],$pos_of_T+1);
        } else {
            $new_time_field = substr($splitted_array[1],0);
        }
        log_this("DEBUG",$g_routine_name,"new_time_field [$new_time_field]");

        # Remember that the old OC file name has the old date format of yyyydoyhhmmss so we have to build the day of year.
        my $year_portion  = substr($new_time_field,0,4);
        my $month_portion = substr($new_time_field,4,2);
        my $day_portion   = substr($new_time_field,6,2);
        my $rest_of_field = substr($new_time_field,9);
        my $day_of_year_portion = convert_year_mm_dd_to_doy($year_portion,$month_portion,$day_portion);
        # If the number of characters is less than 3, we prefill with zeros.
        if (length("$day_of_year_portion") < 3) {
            $day_of_year_portion = sprintf("%03d", $day_of_year_portion); 
        }
        #my $day_of_year_portion = "DUMMY";
        # The new new_time_field now has yeardoyhhmmss
	if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"i_sst_full_name_to_search[$i_sst_full_name_to_search]");
	    log_this("DEBUG",$g_routine_name,"year_portion [$year_portion]");
	    log_this("DEBUG",$g_routine_name,"month_portion [$month_portin]");
	    log_this("DEBUG",$g_routine_name,"day_portion [$day_portion]");
	    log_this("DEBUG",$g_routine_name,"rest_of_field [$rest_of_field]");
	    log_this("DEBUG",$g_routine_name,"new_time_field [$new_time_field]");
	}
	
        $new_time_field = $year_portion . $month_portion . $day_of_year_portion . $rest_of_field;
        
	if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"new_time_field [$new_time_field]");
	}
        #log_this("DEBUG",$g_routine_name,"early#exit#0055");
        #exit(0);

        my $dir_only = dirname($i_sst_full_name_to_search);

        my $name_only = basename($i_sst_full_name_to_search);
        if ((index($name_only,"AQUA") == 0) or (index($name_only,"A") == 0))       {
            $full_oc_name_to_search = $i_scratch_area . "/holding_tank/" . 'A' . $new_time_field . ".L2_LAC_OC.nc";
#            print "AQUA_CASE [$i_sst_full_name_to_search]\n";
        } elsif ((index($i_sst_full_name_to_search,"TERRA") == 0) or (index($i_sst_full_name_to_search,"T") == 0)) {
            $full_oc_name_to_search = $i_scratch_area . "/holding_tank/" . 'T' . $new_time_field . ".L2_LAC_OC.nc";
#            print "TERRA_CASE [$i_sst_full_name_to_search]\n";
        } else {
            # VIIRS has no OC file so we don't need to check
            # pass
#            print "OTHER_CASE [$i_sst_full_name_to_search]\n";
        }
	if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"i_sst_full_name_to_search [$i_sst_full_name_to_search]");
	    log_this("DEBUG",$g_routine_name,"full_oc_name_to_search [$full_oc_name_to_search]");
	}
        if (-e $full_oc_name_to_search) {
            $o_matching_oc_name = $full_oc_name_to_search;
        }
#        print "full_oc_name_to_search [$full_oc_name_to_search]\n";
#        print "i_sst_full_name_to_search [$i_sst_full_name_to_search]\n";
#        print "splitted_array[0] [$splitted_array[0]\n";
#        print "pos_of_T [$pos_of_T]\n";
#        print "new_time_field [$new_time_field] SHOULD_BE 2012285170500\n";
#        print "full_oc_name_to_search [$full_oc_name_to_search]\n";
#        print "dir_only [$dir_only]\n";
#        print "o_matching_oc_name [$o_matching_oc_name]\n";
    }

    # Adding logic to handle OBPG some OC file in HDF format.  This is not pretty but it works.
    # Inorder to look for the HDF file names, we have to remove the .nc file extension.
    # We perform the addtional search if the name to look for is .nc and we haven't found the OC file yet.
    if ((index($name_to_search,".nc") >= 0) && ($o_matching_oc_name eq "")) {
        $name_without_extension = basename($name_to_search,".nc"); # Get the name without the extension.
        $full_oc_name_to_search = $i_scratch_area . "/holding_tank/" . $name_without_extension;
        if ($debug_mode) {
            log_this("INFO",$debug_module,"HOLDING_TANK_SEARCH_FOR_HDF_FILE $full_oc_name_to_search");
        }
        if (-e $full_oc_name_to_search) {
            $o_matching_oc_name = $full_oc_name_to_search;
            log_this("INFO",$g_routine_name,"USING_HDF_VERSION_OC_FILE $full_oc_name_to_search TO_COMBINE_WITH $i_sst_full_name_to_search");
        }
     }

#print "modis_level2_combiner::get_names_from_holding_tank: o_matching_sst4_name [$o_matching_sst4_name]\n";
#print "modis_level2_combiner::get_names_from_holding_tank: o_matching_oc_name   [$o_matching_oc_name]\n";
#exit(0);
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"o_matching_sst4_name [$o_matching_sst4_name]");
	log_this("DEBUG",$g_routine_name,"o_matching_oc_name   [$o_matching_oc_name]");
    }
    #log_this("DEBUG",$g_routine_name,"early#exit#0001");
    #exit(0);


    return ($o_matching_sst4_name,$o_matching_oc_name);
}

#------------------------------------------------------------------------------------------------------------------------
sub is_oc_name_in_list {
    # Given an SST name to search and a list to search in, we look for an OC file name.  This is the Ocean Color file.

    my $i_sst_full_name_to_search  = shift;
    my $i_sst_filenames_ref        = shift;

    my $g_routine_name = 'is_oc_name_in_list:';
    my @i_sst_filenames_list = @$i_sst_filenames_ref;  
    my $o_oc_name_in_list_flag  = 0;                   # Flag set to 1 if found the OC file name.
    my $o_index_found_to_filenames = 0;                # Index of OC file name if found.
    my $o_actual_oc_filename = "DUMMY_OC_FILENAME";    # Actual OC file name

    my $sst_full_name_to_search = $i_sst_full_name_to_search;
    my $find         = "SST.nc";                            # Look for this string.
    my $replace_with = "OC.nc";                             # Replace with this string.
    $find            = quotemeta $find;                     # Escape regex metachars if present.
    $sst_full_name_to_search =~ s/$find/$replace_with/g;  # Do the replacement of SST.nc to OC.nc
    my $o_oc_file_name = $sst_full_name_to_search;

    # Check if oc file exsts
    if (-e $o_oc_file_name) {
        print "FOUND\n";
        $o_actual_oc_filename = $o_oc_file_name;
        $o_oc_name_in_list_flag = 1;
        my ($index) = grep { @i_sst_filenames_list[$_] eq "$o_actual_oc_filename\n" } (0 .. @i_sst_filenames_list-1);          
        $o_index_found_to_filenames = defined $index ? $index : -1;
        
        
    # If the OC.nc file does not exist, check that it does not exist at a different seconds interval.
    } else {
        my @splitted_tokens = split(/\//,$o_oc_file_name);   # Split on backslash to get name only
        my $oc_name_only = $splitted_tokens[-1];
        $o_oc_file_name = find_new_oc_filename($i_sst_full_name_to_search,$oc_name_only);
        if (-e $o_oc_file_name) {
            print "FOUND BY TIME\n";
            $o_actual_oc_filename = $o_oc_file_name;
            $o_oc_name_in_list_flag = 1;
            my ($index) = grep { @i_sst_filenames_list[$_] eq "$o_actual_oc_filename\n" } (0 .. @i_sst_filenames_list-1);          
            $o_index_found_to_filenames = defined $index ? $index : -1;
        }
    }

    return ($o_oc_name_in_list_flag,$o_index_found_to_filenames,$o_actual_oc_filename);
    
}

#------------------------------------------------------------------------------------------------------------------------
sub find_old_oc_filename {
    # Because the old OC filename may not have the correct time, we fudge by looking for the closest second.
    # A2019338132501.L2_LAC_OC.nc
    # We look from A2019338132500.L2_LAC_OC.nc to A2019338132559.L2_LAC_OC.nc
    my $name_from_list  = shift;
    my $old_oc_filename = shift;;
    my $g_routine_name  = 'find_old_oc_filename:';

    my $o_actual_oc_filename = "";

    my $directory_name_only = dirname($name_from_list);
    #$old_oc_filename = $directory_name_only . '/' . $old_oc_filename;

    # Because the old OC filename may not have the correct time, we fudge by looking for the closest second.
    # A2019338132501.L2_LAC_OC.nc

    my @splitted_array = split('\.',$old_oc_filename);  # The dot has to be escaped.
    my $name_only = $splitted_array[0];
    my $partial_name_without_seconds = substr($name_only,0,length($name_only)-2);

    my $second_as_string = '';
    my $name_with_seconds_added = '';
    my $name_to_check = '';

    # Loop through from 0 to 59 and check to see if a file exist.
    for (my $second_value = 0; $second_value < 60; $second_value++) {
        $second_as_string = sprintf("%02d", $second_value);   # '00' to '59'
        $name_with_seconds_added = $partial_name_without_seconds . $second_as_string . ".L2_LAC_OC.nc";
        $name_to_check = $directory_name_only . '/' . $name_with_seconds_added;
        #log_this("DEBUG",$g_routine_name,"name_only [$name_only], second_value [$second_value], name_with_seconds_added [$name_with_seconds_added], name_to_check [$name_to_check]");
        if (-e $name_to_check) {
             $o_actual_oc_filename = $name_to_check;
	     if ($debug_flag) {
		    log_this("DEBUG",$g_routine_name,"FOUND_IT name_to_check [$name_to_check]");
	     }
             last;  # Break out of for loop since we have found the name.
        }
    }

    #log_this("DEBUG",$g_routine_name,"name_only [$name_only]");
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"o_actual_oc_filename [$o_actual_oc_filename]");
    }
    #exit(0);
    return($o_actual_oc_filename);
}

#------------------------------------------------------------------------------------------------------------------------
sub find_new_oc_filename {
    # Because the new OC filename may not have the correct time, we fudge by looking for the closest second.
    # AQUA_MODIS.20191204T132501.L2.OC.nc A2019338132501.L2_LAC_OC.nc
    # We look from AQUA_MODIS.20191204T132500.L2.OC.nc to AQUA_MODIS.20191204T132559.L2.OC.nc
    my $name_from_list  = shift;
    my $new_oc_filename = shift;;
    my $g_routine_name  = 'find_new_oc_filename';

    my $o_actual_oc_filename = "";

    my $directory_name_only = dirname($name_from_list);

    # Because the new OC filename may not have the correct time, we fudge by looking for the closest second.

    my @splitted_array = split('\.',$new_oc_filename);  # The dot has to be escaped.
    my $name_only = $splitted_array[1];  # The name is the 2nd token.
    my $partial_name_without_seconds = $splitted_array[0] . "." . substr($name_only,0,length($name_only)-2);

    my $second_as_string = '';
    my $name_with_seconds_added = '';
    my $name_to_check = '';

    # Loop through from 0 to 59 and check to see if a file exist.
    for (my $second_value = 0; $second_value < 60; $second_value++) {
        $second_as_string = sprintf("%02d", $second_value);   # '00' to '59'
        $name_with_seconds_added = $partial_name_without_seconds . $second_as_string . ".L2.OC.nc";
        $name_to_check = $directory_name_only . '/' . $name_with_seconds_added;   # /data/dev/scratch/qchau/IO/modis/MODIS_AQUA_L2_SST_OBPG_QUICKLOOK/AQUA_MODIS.20191204T132555.L2.OC.nc
        #log_this("DEBUG",$g_routine_name,"name_only [$name_only], second_value [$second_value], name_with_seconds_added [$name_with_seconds_added], name_to_check [$name_to_check]");
        if (-e $name_to_check) {
             $o_actual_oc_filename = $name_to_check;
             log_this("DEBUG",$g_routine_name,"FOUND_IT name_to_check [$name_to_check]");
             last;  # Break out of for loop since we have found the name.
        }
    }

    #log_this("DEBUG",$g_routine_name,"name_only [$name_only]");
    if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"o_actual_oc_filename [$o_actual_oc_filename]");
    }
    #exit(0);
    return($o_actual_oc_filename);
}

#------------------------------------------------------------------------------------------------------------------------
sub prepare_output_work_area_with_error_handling_historical {
    # Prepare the output work area by creating directory if it is not there yet.
    # Also determines if working with Day, Night, or Mixed. NET.

    my $i_sst_filename    = shift;
    my $i_oc_filename     = shift;
    my $i_processing_type = shift;
    my $output_directory  = shift;
    my $sigevent_email_to = shift;
    my $sigevent_clause   = shift;
    my $temp_dir          = shift;
    my $msg2report        = shift;
    my $sigevent_data     = shift;

    my $o_name_only    = "";
    my $o_out_filename = "";
    my $o_oc_filename  = $i_oc_filename;
    my $o_upper_level_output_directory = "";
    my $o_file_extension = "";  # Will be set to the actual file extension depending on when the file was observed.

    my $debug_module = "prepare_output_work_area_with_error_handling_historical:";
    my $routine_name = "prepare_output_work_area_with_error_handling_historical";
    my $debug_mode   = 0;

    #
    # Build the output file name by adding the product type and the year and day of year.
    #
    
    # First remove the directory name of the input file and just get the file name.

    my @splitted_tokens = split(/\//,$i_sst_filename);
    my $num_tokens = @splitted_tokens;
    $o_name_only = $splitted_tokens[$num_tokens-1];  # Get just the name.   We assume the name is the last token.

    # Create the directory if it does not exist yet.
    if (!(-e $output_directory)) {
        my $status_mkdir = mkdir_with_error_handling($output_directory);
        # The mkdir function returns true if successful and false if failed.
        # if ($status_mkdir == 0) { exit(0); }
    }
    
    $o_upper_level_output_directory = strip_trailing_slash($output_directory) . '/' . $i_processing_type;

    # Create the directory if it does not exist yet.
    if (!(-e $o_upper_level_output_directory)) {
        my $status_mkdir = mkdir_with_error_handling($o_upper_level_output_directory);
        # The mkdir function returns true if successful and false if failed.
        # if ($status_mkdir == 0) { exit(0); }
    }
    
    my $o_night_or_day = '';

    # If perform a test, change the value of i_sst_filename to make it fail.
    if ($g_prepare_output_work_area_make_day_night_attribute_failed == 1) { $i_sst_filename = "/tmp/this_file_does_not_exist"; }

    # Give the operator an option to use different method of determining if the file is Night, Day, or Mixed in case there is an issue with the file format.
    # The default method is to use Perl since it is faster by about 3 to 4 seconds.

    my $day_or_night_status = "";         # Note: this variable must be define outside of the if statement below.
    my $when_granule_observed_flag = "";  # Note: this variable must be define outside of the if statement below.



    if ($ENV{GHRSST_MODIS_L2_USE_PERL_VERSION_OF_GLOBAL_ATTRIBUTE_READER} eq "true") {
       # Use Perl to read the global attribute day_night_flag.
        do "$GHRSST_PERL_LIB_DIRECTORY/is_granule_night_or_day_historical.pl";
        ($day_or_night_status,$when_granule_observed_flag) = is_granule_night_or_day_historical($i_sst_filename);
        if ($debug_mode) {
            print $debug_module . "GHRSST_MODIS_L2_USE_PERL_VERSION_OF_GLOBAL_ATTRIBUTE_READER true\n";
        }
    } else {
        # Use IDL to read the global attribute day_night_flag.
        do "$GHRSST_PERL_LIB_DIRECTORY/is_granule_night_or_day.pl";
        ($day_or_night_status,$when_granule_observed_flag) = is_granule_night_or_day($i_sst_filename);
        if ($debug_mode) {
            print $debug_module . "GHRSST_MODIS_L2_USE_PERL_VERSION_OF_GLOBAL_ATTRIBUTE_READER false\n";
        }
    }
#
#
#
#    if ($ENV{GHRSST_MODIS_L2_USE_PERL_VERSION_OF_GLOBAL_ATTRIBUTE_READER} eq "false") {
#        # Use IDL to read the global attribute day_night_flag.
#        do "$GHRSST_PERL_LIB_DIRECTORY/is_granule_night_or_day.pl";
#        ($day_or_night_status,$when_granule_observed_flag) = is_granule_night_or_day($i_sst_filename);
#        if ($debug_mode) {
#            print $debug_module . "GHRSST_MODIS_L2_USE_PERL_VERSION_OF_GLOBAL_ATTRIBUTE_READER false\n";
#        }
#    } else {
#        # Use Perl to read the global attribute day_night_flag.
#        do "$GHRSST_PERL_LIB_DIRECTORY/is_granule_night_or_day_historical.pl";
#        ($day_or_night_status,$when_granule_observed_flag) = is_granule_night_or_day_historical($i_sst_filename);
#        if ($debug_mode) {
#            print $debug_module . "GHRSST_MODIS_L2_USE_PERL_VERSION_OF_GLOBAL_ATTRIBUTE_READER true\n";
#        }
#    }

    # Do a sanity check if there was an error so we can report it to the operator.
    # Value 1 of day_or_night_status means bad, 0 means good.

    if ($debug_mode) {
        print $debug_module . "i_sst_filename                  $i_sst_filename\n";
        print $debug_module . "day_or_night_status             $day_or_night_status\n";
        print $debug_module . "when_granule_observed_flag      $when_granule_observed_flag\n";
        print $debug_module . "g_skip_additional_day_file_flag $g_skip_additional_day_file_flag\n";
    }
    
    if ($day_or_night_status == 1) {
        $sigevent_type = "error";
        $sigevent_msg = "Something went wrong with fetching the Day or Night attribute from file $i_sst_filename";
        log_this("ERROR",$g_routine_name,$sigevent_msg);
        ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
    }
    
    # The only 3 possible values for the returned parameter when_granule_observed_flag are: {'Day', 'Night', 'Mixed'}

    if ($when_granule_observed_flag eq 'Day') {
        $o_night_or_day = 'D';
        $o_file_extension = ".LAC_GSSTD";
    }
    if ($when_granule_observed_flag eq 'Night') {
        $o_night_or_day = 'N';
        $o_file_extension = ".LAC_GSSTN";
    }
    if ($when_granule_observed_flag eq 'Mixed') {
        $o_night_or_day = 'M';
        $o_file_extension = ".LAC_GSSTN";
    }
    
    # We may not need to remove the OC file at all.  It will be used to create the Day version.
    # We only remove the OC file if the additional Day file creation is being skipped.

    if ($g_skip_additional_day_file_flag == 1) {
        # One last sanity check: The LAC_OC file is only used if the SST is Day.  If it is Night or Mixed, we reset the i_oc_filename to dummy name and delete the LAC_OC file.
        if (($o_night_or_day eq 'N') || ($o_night_or_day eq 'M')) {
            # Remove the LAC_OC file if we had found it since it is not useful.
            if ($i_oc_filename ne "DUMMY_OC_FILENAME") {
                if (-e $i_oc_filename) { 
                    log_this("INFO",$g_routine_name,"NIGHT_NOT_NEEDED_REMOVING_FILE " . $i_oc_filename);
                    unlink ($i_oc_filename);
                }
            }
            # Set back to dummy name because a Night/Mixed SST does not need an LAC_OC file since the measurement is only good for the Day.
            $o_oc_filename   = "DUMMY_OC_FILENAME";
        }
    }
    
    # Even though we are setting the output name the same as the i_sst_filename, the IDL code will use the Night or Day attribute and change the output
    # name to something like: A2012192043500.LAC_GSSTD or A2012192043500.LAC_GSSTN,
    
    $o_out_filename  = $o_upper_level_output_directory . "/" . $o_name_only;
    return ($o_night_or_day,$o_name_only,$o_out_filename,$o_upper_level_output_directory,$o_file_extension,$o_oc_filename);
}

#------------------------------------------------------------------------------------------------------------------------
sub strip_trailing_slash {
    # If a name ends with a slash, function will remove it.
    my $i_name = shift;

    my $o_stripped_name = $i_name; 

    # Get the last character from the input name.

    my $name_length = length($i_name);
    my $last_character = substr($i_name,($name_length-1));

    # If the name ends with a slash, get just up to the slash, not including.
    if ($last_character eq '/') { 
        $o_stripped_name = substr($i_name,0,$name_length-1); # Copy up to the '/' character.
    }
   return ($o_stripped_name);
}

#------------------------------------------------------------------------------------------------------------------------
sub proceed_with_processing_sst_file {
    my $i_sst_filename      = shift;
    my $i_staged_sst_filename = shift;
    my $i_sst4_filename     = shift;
    my $i_oc_filename       = shift;
    my $i_threshold_to_wait = shift;

    my $g_routine_name = 'modis_level2_combiner_historical:proceed_with_processing_sst_file:'; 

   # log_this("DEBUG",$g_routine_name,"i_sst_filename,i_sst4_filename,i_oc_filename [$i_sst_filename] [$i_sst4_filename] [$i_oc_filename] [$o_night_or_day] [$o_file_age] [$i_threshold_to_wait] [$o_proceed_flag]");

    #my $o_time_passed_expiration = 0;
    my $o_proceed_flag = 1;
    my $o_file_age               = 0;
    my $o_night_or_day = '';

    my $time_now = time();
    my $seconds_difference_between_sst_and_now = 0;
    my $minutes_difference_between_sst_and_now = 0;
    my $hours_difference_between_sst_and_now   = 0;
    my $last_modified_time_of_sst              = 0;

    # Do a sanity check if the file exist.
    if (-e $i_sst_filename) {
        log_this("INFO",$g_routine_name,"FILE_EXISTENCE_CHECK_ORIGINAL_SST_FILENAME $i_sst_filename");
        $last_modified_time_of_sst = (stat($i_sst_filename))[9];  # Get last modified time in seconds since 1970
    } elsif (-e $i_staged_sst_filename) {
        log_this("INFO",$g_routine_name,"FILE_EXISTENCE_CHECK_STAGED_SST_FILENAME $i_staged_sst_filename");
        $last_modified_time_of_sst = (stat($i_staged_sst_filename))[9];  # Get last modified time in seconds since 1970
    } else {
        log_this("ERROR",$g_routine_name,"Neither files were found $i_sst_filename $i_staged_sst_filename");
        exit(0);
    }

    $seconds_difference_between_sst_and_now = $time_now - $last_modified_time_of_sst;
    $minutes_difference_between_sst_and_now = sprintf("%.0f",$seconds_difference_between_sst_and_now/60);
    $o_file_age = $minutes_difference_between_sst_and_now;
    $hours_difference_between_sst_and_now   = sprintf("%.0f",$seconds_difference_between_sst_and_now/3600);

    my ($day_or_night_status,$when_granule_observed_flag) = is_granule_night_or_day($i_sst_filename);

    if ($when_granule_observed_flag eq 'Day') {
            $o_night_or_day = 'D';
    }
    if ($when_granule_observed_flag eq 'Night') {
        $o_night_or_day = 'N';
    }
    if ($when_granule_observed_flag eq 'Mixed') {
        $o_night_or_day = 'M';
    }

    # If night or mixed, we check for name of i_sst4_filename to see if it is a dummy.
    if ($o_night_or_day eq 'N' or $o_night_or_day eq 'M') {
        # If we don't already have a legitimate SST4 file name and the time difference is smaller than threshold, we don't proceed with processing this SST.
        if ($o_night_or_day eq 'M') {
            # If mixed, we look to see if either of the file is dummy.  We will not proceeed if we are within the threshold wait.
            if ((index($i_sst4_filename,'DUMMY') >= 0) or (index($i_oc_filename,'DUMMY') >= 0)) {
                if ($minutes_difference_between_sst_and_now < $i_threshold_to_wait) {
                    $o_proceed_flag = 0;
                }
            }
        } else {
            if (index($i_sst4_filename,'DUMMY') >= 0) {
                if ($minutes_difference_between_sst_and_now < $i_threshold_to_wait) {
                    $o_proceed_flag = 0;
                }
            }
        }

    } elsif ($o_night_or_day eq 'D') {
        # If day, we check for name of i_oc_filename to see if it is a dummy.
        if (index($i_oc_filename,'DUMMY') >= 0) {
            if ($minutes_difference_between_sst_and_now < $i_threshold_to_wait) {
                $o_proceed_flag = 0;
            }
        }
    }

    log_this("DEBUG",$g_routine_name,"i_sst_filename,i_staged_sst_filename,i_sst4_filename,i_oc_filename [$i_sst_filename] [$i_staged_sst_filename] [$i_sst4_filename] [$i_oc_filename] [$o_night_or_day] [$o_file_age] [$i_threshold_to_wait] [$o_proceed_flag]");
    #exit(0);
    return ($o_proceed_flag,$o_file_age,$o_night_or_day);
}

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";

}
