#!/usr/local/bin/perl
#  Copyright 2014, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Subroutine moves a file just combined to final destination.  This function is used in the MODIS Level 2 Combiner.

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};

do "$GHRSST_PERL_LIB_DIRECTORY/mkdir_with_error_handling.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/ghrsst_notify_operator.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/raise_sigevent.pl";
do "$GHRSST_PERL_LIB_DIRECTORY/convert_year_mm_dd_to_doy.pl";

use File::Basename;
use File::Copy;

my $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
my $sigevent_provider      = "JPL";
my $sigevent_source        = "GHRSST-PROCESSING";
my $sigevent_type          = "";
my $sigevent_category      = 'UNCATEGORIZED';
my $sigevent_description   = "";
my $sigevent_data          = "This is sigevent_data";

#------------------------------------------------------------------------------------------------------------------------
sub move_combined_file_to_final_location {
    my $g_routine_name = 'move_combined_file_to_final_location:';

    # Move the just created file to its final location.
    # We use the value of i_processing_type together with the name to figure out where to place the file.

    my $i_output_directory    = shift;
    my $i_processing_type     = shift;
    my $i_name_only           = shift;
    my $i_actual_file_to_look = shift;

    # We've opted not to use the i_ convention for the rest of the input variables to keep the function call the same.

    my $output_file_name_wild_search = shift;
    my $sigevent_email_to            = shift;
    my $sigevent_clause              = shift;
    my $temp_dir                     = shift;
    my $msg2report                   = shift;

    # Create the output directory.

    my $upper_level_output_directory = strip_trailing_slash($i_output_directory) . '/' . $i_processing_type;

    # Create the directory if it does not exist yet.
    # FIX_ME
    #$upper_level_output_directory = "/tmp_you_cannot_create_this";
    if (!(-e $upper_level_output_directory)) {
        my $status_mkdir = mkdir_with_error_handling($upper_level_output_directory);
        if ($status_mkdir == 0) { 
            log_this("ERROR",$g_routine_name,"MKDIR_FAILED $upper_level_output_directory");
            exit(1);
        }
    }

    # Parse the file name for year and day of year so we know where to move the file to.
    #
    # The year is the 2nd token, 4 characters long, the day of year is the 6th token, 3 characters long:
    #
    #     A2012234150500.L2_LAC_SST
    #     01234567

    my $year_portion        =  "DUMMY_YEAR_PORTION";
    my $day_of_year_portion = "DUMMY_DAY_OF_YEAR_PORTION";
    # Do a sanity check on the name of the file for 2019 OBPG naming pattern.
    if (index($i_name_only,"L2.SST") >= 0) {   # Check for MODIS_AQUA.20120204T150500.L2.SST.nc
        my $first_dot_pos = index($i_name_only,"."); 
        $year_portion        = substr($i_name_only,$first_dot_pos+1,4);
        my $month_portion    = substr($i_name_only,$first_dot_pos+5,2); # 02
        my $day_portion      = substr($i_name_only,$first_dot_pos+7,2); # 04
        log_this("DEBUG",$g_routine_name,"#0050:i_name_only[$i_name_only]");
        log_this("DEBUG",$g_routine_name,"#0050:year_portion [$year_portion]");
        log_this("DEBUG",$g_routine_name,"#0050:month_portion [$month_portion]");
        log_this("DEBUG",$g_routine_name,"#0050:day_portion [$day_portion]");
        #log_this("DEBUG",$g_routine_name,"#0050:#early#exit#0049");
        #exit;
        $day_of_year_portion = convert_year_mm_dd_to_doy($year_portion,$month_portion,$day_portion);
        #$day_of_year_portion = substr($i_name_only,$first_dot_pos+5,3);
    } else {
        $year_portion = substr($i_name_only,1,4);
        $day_of_year_portion = substr($i_name_only,5,3);
    }

    $upper_level_output_directory = $upper_level_output_directory . "/" . $year_portion;
    log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:i_actual_file_to_look[$i_actual_file_to_look]");
    log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:i_name_only[$i_name_only]");
    log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:year_portion[$year_portion]");
    log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:day_of_year_portion[$day_of_year_portion]");
    log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:upper_level_output_directory [$upper_level_output_directory]");
    #log_this("DEBUG",$g_routine_name,"#0050:#early#exit#0049");
    #exit;

    # FIX_ME
    #$upper_level_output_directory = "/tmp_you_cannot_create_this";
    # Create the directory if it does not exist yet.  This directory now contains the year only.
    if (!(-e $upper_level_output_directory)) {
        my $status_mkdir = mkdir_with_error_handling($upper_level_output_directory);
        if ($status_mkdir == 0) { 
            log_this("ERROR",$g_routine_name,"MKDIR_FAILED $upper_level_output_directory");
            exit(1);
        }
    }

    $upper_level_output_directory = $upper_level_output_directory . "/" . $day_of_year_portion;
    log_this("DEBUG",$g_routine_name,"#0050:VARIABLE_CHECK:upper_level_output_directory [$upper_level_output_directory]");
    #log_this("DEBUG",$g_routine_name,"#0050:#early#exit#0049");
    #exit;

    # FIX_ME
    #$upper_level_output_directory = "/tmp_you_cannot_create_this";
    # Create the directory if it does not exist yet.  This directory now contains the year and day of year.
    if (!(-e $upper_level_output_directory)) {
        my $status_mkdir = mkdir_with_error_handling($upper_level_output_directory);
        if ($status_mkdir == 0) { 
            log_this("ERROR",$g_routine_name,"MKDIR_FAILED $upper_level_output_directory");
            exit(1);
        }
    }

    # Finally, we can rename the newly combined file to its new location for the MODIS L2P Processing to pick up.
    #
    # Note: Because the legacy code that the does the data pulling prepends "refined_" to the name of the refined products, we should do the same thing,
    #       so the MODIS L2P can have the same expectation.

    # FIX_ME
    #$i_actual_file_to_look = "";
    if (index($i_processing_type,"REFINED") >= 0) {
        # Moving REFINED file to its final destination.
        if (($i_actual_file_to_look ne '') && (-e $i_actual_file_to_look)) {
            my $file_name = basename($i_actual_file_to_look);
            $file_name = "refined_" . $file_name;
            system("mv $i_actual_file_to_look $upper_level_output_directory/$file_name");
            if ($g_debug) { log_this("DEBUG",$g_routine_name,"mv $i_actual_file_to_look $upper_level_output_directory/$file_name"); }

            # If running a test, set the file_name to something that we know does not exist.
            if ($ENV{GHRSST_L2_MOVING_TO_NON_EXISTENCE_DIRECTORY} eq 'true') {
                $file_name = "this_file_should_not_exist";
            }

            # Do a sanity check on the success of the move command.

            if (-e "$upper_level_output_directory/$file_name") {
                $log_message = "COMBINED_FILE_CREATED ". $upper_level_output_directory . "/" . $file_name;
                log_this("INFO",$g_routine_name,$log_message);
                $log_message = "FILE_MOVE_SUCCESSFUL $i_actual_file_to_look ". $upper_level_output_directory . "/" . $file_name;
                log_this("INFO",$g_routine_name,$log_message);

                if ($g_debug) {
                    $sigevent_type = "information";
                    $sigevent_msg = "$upper_level_output_directory/$file_name created.";
                    $sigevent_data = ""; # Must reset to empty string to signify there's no data to pass along.
                    ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
                }
            } else {
                log_this("ERROR",$g_routine_name,"FILE_MOVE_FAILED $i_actual_file_to_look $upper_level_output_directory/$file_name");
                $sigevent_type = "ERROR";
                $sigevent_description = "FILE_MOVE_FAILED $i_actual_file_to_look $upper_level_output_directory/$file_name";
                raise_sigevent($sigevent_url,$sigevent_provider,$sigevent_source,$sigevent_type,$sigevent_category,$sigevent_description,$sigevent_data,$sigevent_debug_flag);
                return;
            }
        } else {
            # If we cannot find an expected output file, then something has went wrong with the IDL routine.  Log it and raise the sigevent so the operator will know about it.
            $sigevent_type = "error";
            $sigevent_msg = "Something went wrong with the IDL combine routine.  An input was expected here $i_actual_file_to_look";
            $sigevent_msg_2 = "#0003:Something went wrong with the IDL combine routine.  An input was expected here i_actual_file_to_look [$i_actual_file_to_look]";
            log_this("ERROR",$g_routine_name,$sigevent_msg_2);
            log_this("ERROR",$g_routine_name,$sigevent_msg);
            ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
        }
    } else {
        # Moving QUICKLOOK file to its final destination.
        if (($i_actual_file_to_look ne '') && (-e $i_actual_file_to_look)) {
            system("mv $i_actual_file_to_look $upper_level_output_directory");
            my $file_name = basename($i_actual_file_to_look);
            if ($g_debug) { log_this("DEBUG",$g_routine_name,"mv $i_actual_file_to_look $upper_level_output_directory"); }

            # If running a test, set the file_name to something that we know does not exist.
            if ($ENV{GHRSST_L2_MOVING_TO_NON_EXISTENCE_DIRECTORY} eq 'true') {
                $file_name = "this_file_should_not_exist";
            }

            # Do a sanity check on the success of the move command.
            if (-e "$upper_level_output_directory/$file_name") {
                $log_message = "COMBINED_FILE_CREATED ". $upper_level_output_directory . "/" . $file_name;
                log_this("INFO",$g_routine_name,$log_message);
                $log_message = "FILE_MOVE_SUCCESSFUL $i_actual_file_to_look ". $upper_level_output_directory . "/" . $file_name;
                log_this("INFO",$g_routine_name,$log_message);

                if ($g_debug) {
                    $sigevent_type = "information";
                    $sigevent_msg = "$upper_level_output_directory/$file_name created.";
                    $sigevent_data = "";  # Must reset to empty string to signify there's no data to pass along.
                    ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
                }
            } else {
                $sigevent_type = "ERROR";
                $sigevent_description = "FILE_MOVE_FAILED $i_actual_file_to_look $upper_level_output_directory/$file_name";
                raise_sigevent($sigevent_url,$sigevent_provider,$sigevent_source,$sigevent_type,$sigevent_category,$sigevent_description,$sigevent_data,$sigevent_debug_flag);
                log_this("ERROR",$g_routine_name,"FILE_MOVE_FAILED $i_actual_file_to_look $upper_level_output_directory/$file_name");
                return;
            }
        } else {
            # If we cannot find an expected output file, then something has went wrong with the IDL routine.  Log it and raise the sigevent so the operator will know about it.
            $sigevent_type = "error";
            $sigevent_msg = "Something went wrong with the IDL combine routine.  An input file was expected here $i_actual_file_to_look";
            $sigevent_msg_2 = "#0004:Something went wrong with the IDL combine routine.  An input was expected here i_actual_file_to_look [$i_actual_file_to_look]";
            log_this("ERROR",$g_routine_name,$sigevent_msg_2);
            log_this("ERROR",$g_routine_name,$sigevent_msg);
            ghrsst_notify_operator($g_routine_name,$sigevent_type,$sigevent_msg,$sigevent_email_to,$sigevent_clause,$temp_dir,$msg2report,$sigevent_data);
        }
    }
}

#------------------------------------------------------------------------------------------------------------------------
sub strip_trailing_slash {
    # If a name ends with a slash, function will remove it.
    my $i_name = shift;

    my $o_stripped_name = $i_name;

    # Get the last character from the input name.

    my $name_length = length($i_name);
    my $last_character = substr($i_name,($name_length-1));

    # If the name ends with a slash, get just up to the slash, not including.
    if ($last_character eq '/') {
        $o_stripped_name = substr($i_name,0,$name_length-1); # Copy up to the '/' character.
    }
   return ($o_stripped_name);
}

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";
}
