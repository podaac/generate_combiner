#!/usr/local/bin/perl
#  Copyright 2016, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Subroutine verify if the final location of the combined file exist.  This does not assume if the file exist or not, just where we think the file will end up.

use File::Basename;
use File::Copy;

do "$GHRSST_PERL_LIB_DIRECTORY/convert_year_mm_dd_to_doy.pl";


my $debug_flag = 0;

if ($ENV{GHRSST_MODIS_L2_COMBINER_DEBUG_MODE} eq "true") {
    $debug_flag = 1;
}

#------------------------------------------------------------------------------------------------------------------------
sub check_combined_file_final_location_historical {

    # Get the just created file its final location.  If it exists, returns the name in o_final_location_historical and o_file_created_successfully_flag as 1.
    # We use the output directory, value of i_processing_type together with the name to figure out where the file was placed.

    my $i_output_directory    = shift;  # /data/dev/scratch/qchau/scratch/AQUA_REFINED
    my $i_processing_type     = shift;  # {AQUA_REFINED,AQUA_QUICKLOOK,TERRA_REFINED,TERRA_QUICKLOOK}
    my $i_file_extension      = shift;  # {LAC_GSSTN,LAC_GSSTD}
    my $i_name_only           = shift;  # A2012234150500.L2_LAC_SST

    my $g_routine_name = "check_combined_file_final_location_historical:";

    my $o_file_created_successfully_flag = 0;
    my $o_final_location_historical      = "";
    my $o_actual_file_to_look            = "";

    my $debug_module = "check_combined_file_final_location_historical:";
    my $debug_mode   = 0;

    # Remove any trailing slashes for a cleaner file name.

    my $upper_level_output_directory = strip_trailing_slash($i_output_directory);

    # Parse the file name for year and day of year so we know where to move the file to.
    #
    # The year is the 2nd token, 4 characters long, the day of year is the 6th token, 3 characters long:
    #
    #     A2012234150500.L2_LAC_SST
    #     01234567

    my $year_portion        = "DUMMY_YEAR_PORTION";
    my $day_of_year_portion = "DUMMY_DAY_OF_YEAR_PORTION";
    # Do a sanity check on the name of the file for 2019 OBPG naming pattern.
    if (index($i_name_only,"L2.SST.nc") >= 0) {
        # Do one final check to see if the value of i_name_only is AQUA_MODIS.2019289042500.L2.SST.nc.
        # Do one final check to see if the value of i_name_only is AQUA_MODIS.20190204T042500.L2.SST.nc.
        my $pos_first_dot = index($i_name_only,".");
        #my $pos_second_dot = index($i_name_only,".",$pos_first_dot+1);
        $year_portion        = substr($i_name_only,$pos_first_dot+1,4); # 2019 
        #if index($i_name_only,'T') >= 0) {
        #    my $month_portion    = substr($i_name_only,$pos_first_dot+5,2); # From V20190625T235400 get 02
        #    my $day_portion      = substr($i_name_only,$pos_first_dot+7,2); # 04
        #} else {
            my $month_portion    = substr($i_name_only,$pos_first_dot+5,2); # 02
            my $day_portion      = substr($i_name_only,$pos_first_dot+7,2); # 04
        #}
        #log_this("DEBUG",$g_routine_name,"#0052:#early#exit#0049");
        #exit;
        $day_of_year_portion = convert_year_mm_dd_to_doy($year_portion,$month_portion,$day_portion);
	if ($debug_flag) {
	    log_this("DEBUG",$g_routine_name,"#0052:year_portion[$year_portion]");
	    log_this("DEBUG",$g_routine_name,"#0052:month_portion[$month_portion]");
	    log_this("DEBUG",$g_routine_name,"#0052:day_portion[$day_portion]");
	    log_this("DEBUG",$g_routine_name,"#0052:day_of_year_portion[$day_of_year_portion]");
	}
    } else {
        # If the name contains a T, we convert the month and day into day of year.
        if (index($i_name_only,'T') > 1) {
            $year_portion        = substr($i_name_only,1,4); # 2012
            my $month_portion    = substr($i_name_only,$pos_first_dot+5,2); # 02
            my $day_portion      = substr($i_name_only,$pos_first_dot+7,2); # 04
            $day_of_year_portion = convert_year_mm_dd_to_doy($year_portion,$month_portion,$day_portion);
            #$day_of_year_portion = substr($i_name_only,5,3); #  234
        } else {
            $year_portion        = substr($i_name_only,1,4); # 2012
            $day_of_year_portion = substr($i_name_only,5,3); #  234
        }
    }

    # Build up the actual output directory by adding the year and day of year to keep with the convention of the output directory:
    $upper_level_output_directory = $upper_level_output_directory . "/" . $year_portion;         # /data/dev/scratch/qchau/scratch/AQUA_REFINED/2012
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"#0052:i_name_only[$i_name_only]");
	log_this("DEBUG",$g_routine_name,"#0052:day_of_year_portion[$day_of_year_portion]");
	log_this("DEBUG",$g_routine_name,"#0051:upper_level_output_directory[$upper_level_output_directory]");
    }
    $upper_level_output_directory = $upper_level_output_directory . "/" . $day_of_year_portion;  # /data/dev/scratch/qchau/scratch/AQUA_REFINED/2012/234
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"#0052:upper_level_output_directory[$upper_level_output_directory]");
    }
    #log_this("DEBUG",$g_routine_name,"#0052:#early#exit#0049");
    #exit;


    # Because the output file actually created is something like:
    #    
    #     A2012234150500.LAC_GSSTN
    #    
    # and our variable i_name_only is something like
    #    
    #     A2012234150500.L2_LAC_SST
    #    
    # we have to do a search to look for any file with the name A2012234150500.LAC_GSSTN*

    # Get the name without extension.
    # Do a sanity check on the name of the file for 2019 OBPG naming pattern.
    my $pos_of_dot = "";
    my $name_without_extension = ""; 
    if (index($i_name_only,"L2.SST.nc") >= 0) {
        $pos_of_dot = index($i_name_only,".nc");
        # Do one final check to see if the value of i_name_only is AQUA_MODIS.2019289042500.L2.SST.nc.
        # The actual output file is A2019289042500.LAC_GSSTN.nc so we fetch the first character, plus the rest of the name.
        my $pos_first_dot  = index($i_name_only,".");
        my $pos_second_dot = index($i_name_only,".",$pos_first_dot+1);
        if (index($i_name_only,"VIIRS") >= 0) {
            # For VIIRS instrument, we just add V because name is SNPP_VIIRS.2019176235400.L2.SST.nc
            $name_without_extension = 'V' . substr($i_name_only,$pos_first_dot+1,$pos_second_dot-$pos_first_dot-1);
        } else {
            $name_without_extension = substr($i_name_only,0,1) . substr($i_name_only,$pos_first_dot+1,$pos_second_dot-$pos_first_dot-1);
        }
        #$name_without_extension = substr($i_name_only,0,$pos_of_dot);
    } else {
        $pos_of_dot = index($i_name_only,".");
        $name_without_extension = $i_name_only;
        if ($pos_of_dot > 0) { 
            $name_without_extension = substr($i_name_only,0,$pos_of_dot);
        }    
    }
    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"#0052:i_name_only[$i_name_only]");
	log_this("DEBUG",$g_routine_name,"#0052:name_without_extension[$name_without_extension]");
	log_this("DEBUG",$g_routine_name,"#0052:i_file_extension[$i_file_extension]");
    }
    #log_this("DEBUG",$g_routine_name,"#0052:#early#exit#0049");
    #exit;

    # Becareful to add "*" at the end of the search string to get the correct result.
    # Without the "*", the glob function was falsely return the file name.

    my $o_output_file_name_wild_search = ""; 
    if (index($i_processing_type,"REFINED") >= 0) {
        $o_output_file_name_wild_search = $upper_level_output_directory . "/refined_" . $name_without_extension . $i_file_extension . "*"; 
    } else {
        $o_output_file_name_wild_search = $upper_level_output_directory . "/"         . $name_without_extension . $i_file_extension . "*"; 
    }

    # Get a list of names matching our expression because don't know the exact name.  We expect at least 1 should returned.
    my @file_list = glob($o_output_file_name_wild_search);

    my $num_names_found = scalar(@file_list);

    if ($debug_flag) {
	log_this("DEBUG",$g_routine_name,"#0052:o_output_file_name_wild_search[$o_output_file_name_wild_search]");
	log_this("DEBUG",$g_routine_name,"#0052:num_names_found[$num_names_found]");
    }
    #log_this("DEBUG",$g_routine_name,"#0052:#early#exit#0049");
    #exit;

    # If there was at least one name, we get the first one.

    if ($num_names_found >= 1) { 
        $o_actual_file_to_look = $file_list[0];
        $o_file_created_successfully_flag = 1; 
    }    

    if ($debug_mode) {
        print $debug_module . "name_without_extension         [$name_without_extension]\n";
        print $debug_module . "o_output_file_name_wild_search [$o_output_file_name_wild_search]\n";
        print $debug_module . "num_names_found                [$num_names_found]\n";
    }

    # Checking for the file in its final destination.
    if (($o_actual_file_to_look ne '') && (-e $o_actual_file_to_look)) {
        # Get just the name and add the.
        my $file_name = basename($o_actual_file_to_look);
        $o_final_location_historical = $upper_level_output_directory . "/" . $file_name;

        # Does the file exist.

        if (-e $o_final_location_historical) {
            if ($debug_mode) {
                $log_message = "COMBINED_FILE_CHECKED_SUCCESSFULLY ". $o_final_location_historical;
                log_this("INFO",$g_routine_name,$log_message);
            }
        } else {
            log_this("WARN",$g_routine_name,"COMBINED_FILE_CHECKED_FAILED $o_final_location_historical EITHER_FAILED_TO_COMBINED_OR_NEXT_STAGE_MODIS_L2P_PROCESSING MOVED_IT");
        }
    } else {
        # If we cannot find an expected output file, then something has went wrong with the IDL routine that created it.
        #  Log it and raise the sigevent so the operator will know about it.
        log_this("WARN",$g_routine_name,"COMBINED_FILE_CHECKED_FAILED $o_final_location_historical EITHER_FAILED_TO_COMBINED_OR_NEXT_STAGE_MODIS_L2P_PROCESSING MOVED_IT");
    }

    if ($debug_mode) {
        print $debug_module . "i_output_directory          [$i_output_directory]\n";
        print $debug_module . "i_processing_type           [$i_processing_type]\n";
        print $debug_module . "i_file_extension            [$i_file_extension]\n";
        print $debug_module . "i_name_only                 [$i_name_only]\n";
        print $debug_module . "o_actual_file_to_look       [$o_actual_file_to_look]\n";
        print $debug_module . "o_final_location_historical [$o_final_location_historical]\n";
    }
    #log_this("DEBUG",$g_routine_name,"#0052:#early#exit#0049");
    #exit;

    return($o_file_created_successfully_flag,
           $o_final_location_historical,
           $o_actual_file_to_look);
}

#------------------------------------------------------------------------------------------------------------------------
sub strip_trailing_slash {
    # If a name ends with a slash, function will remove it.
    my $i_name = shift;

    my $o_stripped_name = $i_name;

    # Get the last character from the input name.

    my $name_length = length($i_name);
    my $last_character = substr($i_name,($name_length-1));

    # If the name ends with a slash, get just up to the slash, not including.
    if ($last_character eq '/') {
        $o_stripped_name = substr($i_name,0,$name_length-1); # Copy up to the '/' character.
    }
   return ($o_stripped_name);
}

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";
}
