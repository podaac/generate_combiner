#!/usr/local/bin/perl
#  Copyright 2014, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Location of GHRSST Perl library functions.

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};

do "$GHRSST_PERL_LIB_DIRECTORY/raise_sigevent.pl";

use File::Basename;
use File::Copy;

# Some variables related to sigevent.

my $sigevent_provider      = "JPL";
my $sigevent_type = "information";
my $sigevent_category = "UNCATEGORY";
my $sigevent_msg = "hello there";
my $sigevent_email_to = "DUMMY_EMAIL";
my $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
my $sigevent_source = "GHRSST-PROCESSING";

my $g_debug_flag = 0;
my $g_trace_flag = 0;

#------------------------------------------------------------------------------------------------------------------------
sub file_move_with_error_handling {
    # Function perform a move() on the file to be moved to destination directory name and returns 1 if successful and 0 if failed.
    # A sigevent will be raised if the file cannot be moved.

    my $i_filename_to_move = shift;
    my $i_destination_name = shift;

    my $o_move_status = 1;

    # Do a sanity check by checking to see if the input file exists.
    if (!(-e $i_filename_to_move)) {
        $o_move_status = 0;
        $sigevent_msg = "FILE_MOVE_FAILED_SOURCE_FILE_DOES_NOT_EXIST " . $i_filename_to_move;
        $sigevent_type = "ERROR";
        $sigevent_category = "GENERATE";
        $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
        log_this("ERROR",$g_routine_name,$sigevent_msg);
        raise_sigevent($sigevent_url,$sigevent_provider,$sigevent_source,$sigevent_type,$sigevent_category,$g_routine_name . ":" . $sigevent_msg,$sigevent_data);
        return($o_move_status);
    }

    # If the destination ends with a slash, we assume it is a directory.
    my $destination_is_directory_flag = 0;  # Assume the destination if not a directory first.

#print "last character [" . substr($i_destination_name,length($i_destination_name)-1,1) . "]\n";

    my $last_character_of_destination = substr($i_destination_name,length($i_destination_name)-1,1);
    if ($last_character_of_destination eq '/') {
        $destination_is_directory_flag = 1;
    }

    # If the destination is a directory and it does not exist yet, we return immediately.

    if (($destination_is_directory_flag) and (!(-e $i_destination_name))) {
        $o_move_status = 0;
        $sigevent_msg = "FILE_MOVE_FAILED_OUTPUT_DIRECTORY_DOES_NOT_EXIST [$i_destination_name]";
        $sigevent_type = "ERROR";
        $sigevent_category = "GENERATE";
        $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
        log_this("ERROR",$g_routine_name,$sigevent_msg);
        raise_sigevent($sigevent_url,$sigevent_provider,$sigevent_source,$sigevent_type,$sigevent_category,$g_routine_name . ":" . $sigevent_msg,$sigevent_data);
        return($o_move_status);
    }

    # Depends on if the destination is a directory or a file, we parse for the directory and file name.
    my $parent_directory_name = dirname($i_destination_name);
    my $name_only             = "";
    my $actual_destination_filename = "";
    if ($destination_is_directory_flag) {
        $parent_directory_name = $i_destination_name;           # The destination is a directory /data/dev/scratch/combiner_workspace/, then the parent directory is /data/dev/scratch/combiner_workspace/
        $name_only             = basename($i_filename_to_move); # Get the file name from the source file name.
    } else {
        $name_only             = basename($i_destination_name); # Get the file name from the destination
    }
    if ($destination_is_directory_flag) {
        $actual_destination_filename = $parent_directory_name . $name_only;
    } else {
        $actual_destination_filename = $parent_directory_name . "/" . $name_only;
    }    

    if ($g_trace_flag) {
        print "i_filename_to_move [$i_filename_to_move]\n";
        print "i_destination_name [$i_destination_name]\n";
        print "parent_directory_name [$parent_directory_name]\n";
        print "name_only             [$name_only]\n";
        print "actual_destination_filename [$actual_destination_filename]\n";
    }

    # At this point, we know that the destination is either a directory or a file with an existing directory.
    # The file can then be moved.

    # Use the module File::Copy to do the move.
    move($i_filename_to_move,$i_destination_name);

    # Do a sanity check on the actual destination file.
    if (-e $actual_destination_filename) {
        # Do nothing, this is good.  We have successfully moved the file.
#        if ($g_debug_flag) {
            $sigevent_msg = "FILE_MOVE_SUCCESSFUL $i_filename_to_move $actual_destination_filename";
            log_this("INFO",$g_routine_name,$sigevent_msg);
#        }
    } else {
        $o_move_status = 0;
        # Notify operator and return.
        $sigevent_msg = "FILE_MOVE_FAILED FROM " . $i_filename_to_move . " TO " . $i_destination_name;
        $sigevent_type = "ERROR";
        $sigevent_category = "GENERATE";
        $sigevent_url = $ENV{GHRSST_SIGEVENT_URL};
        log_this("ERROR",$g_routine_name,$sigevent_msg);
        raise_sigevent($sigevent_url,$sigevent_provider,$sigevent_source,$sigevent_type,$sigevent_category,$g_routine_name . ":" . $sigevent_msg,$sigevent_data);
    }

    # If the name contains "NRT" we rename the file to be without it.
    # So we go from SNPP_VIIRS.20190625T235400.L2.SST3.NRT.nc to SNPP_VIIRS.20190625T235400.L2.SST3.nc
    log_this("DEBUG",$g_routine_name,"actual_destination_filename [$actual_destination_filename]");
    if (index($actual_destination_filename,".NRT") >= 0) {
        my $name_without_nrt_token = $actual_destination_filename;
        $name_without_nrt_token =~ s/.NRT//ig;
        log_this("DEBUG",$g_routine_name,"name_without_nrt_token [$name_without_nrt_token]");
        rename($actual_destination_filename,$name_without_nrt_token);
    }

    return($o_move_status);
}

sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";
}

