#!/usr/local/bin/perl

#  Copyright 2012, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

#
# Function take a snapshot of the content of a directory and returns the
# name of file containing one line per file.  This is different than function take_directory_snapshot.pl in that
# it uses the system find command to look for file of a certain days old (default is 12), therefore limit
# the search of a potentially very large directory.
#
#   1) A file of zero size is returned if directory is empty or non-existence.
#
#------------------------------------------------------------------------------------------------

do "$GHRSST_PERL_LIB_DIRECTORY/create_random_filename.pl";

sub big_directory_crawl {

    # Returned status.  Value of 0 means ok, 1 means bad.

    my $r_status = 0;

    # Get input.

    my $input_directory = shift;
    my $search_string   = shift;
    my $scratch_area    = shift;
    my $source_name     = lc(shift);
    my $i_current_time  = shift;
    my $i_optional_days_back = shift;

    # Set to default 10000 days if user did not specify the number of days back to look.

    my $days_back_to_search = 10000;  # Default number of days back to search to 10000 days (or 27 years).

    if ($i_optional_days_back ne '') {
        # Do a sanity check to make sure the value is positive.  No upper limit to how big the number can be.
        if ($i_optional_days_back le 0) {
#            die "big_directory_crawl: i_optional_days_back[$i_optional_days_back] is less than or equal zero days.  Value must be a positive number.   Cannot proceed.  \n";
            print "big_directory_crawl:ERROR:i_optional_days_back[$i_optional_days_back] is less than or equal zero days.  Value must be a positive number.\n";
        }
        # Proceed as normal.
        $days_back_to_search = $i_optional_days_back;
    }

#print "big_directory_crawl: i_optional_days_back[$i_optional_days_back]\n";
#print "big_directory_crawl: days_back_to_search [$days_back_to_search]\n";

    # Returned variables:

#print "big_directory_crawl: Calling create_random_filename.\n";
#print "big_directory_crawl: source_name [$source_name]\n";
#print "big_directory_crawl: search_string [$search_string]\n";
    my $r_tmp_filelist = create_random_filename(
                                 $i_current_time,("$source_name" . "_" . lc($search_string)),
                                 "scratch_filelist");

    # Create an empty file to start with.
    # File should not exist already.  If it is, print a message and exit.  Doesn't make sense to
    # to continue.

    if (-e $r_tmp_filelist) {
        $file_existed_already = 1;
        print "big_directory_crawl: ERROR, Scratch file $r_tmp_filelist exist.\n";
        print "Please delete scratch file and re-run script.\n";
        $r_status = 1;
        return($r_status, $r_tmp_filelist);
    } else {
        system("touch $r_tmp_filelist")  == 0
            or die "big_directory_crawl: Cannot create empty scratch file $r_tmp_filelist: $?";
    }

    my $unsorted_tmp_filelist = $r_tmp_filelist . "_unsorted";
    # Since we only want to find files only, we add the "-type f" to the find command.
    # Code change was to support VIIRS dataset when the search string matches the directory name, which the find command will return as one of the name,
    # not something we want.
    my @r_tmp_filelist = readpipe("find $input_directory -maxdepth 1 -type f -name '" . $search_string . "*'". " -mtime -$days_back_to_search > $unsorted_tmp_filelist");

    # Because the names returned may not be sorted, we do one final sanity check by sorted the content of
    # unsorted_tmp_filelist to file in r_tmp_filelist variable.

    # Add logic to allow the list to have the normal ordering.  If GHRSST_SORT_BY_ALPHANUMERIC is not specified, it will default to reverse sort.

    if ($ENV{GHRSST_SORT_BY_ALPHANUMERIC} eq 'true') {
        system("sort $unsorted_tmp_filelist > $r_tmp_filelist");
    } else {
        system("sort -r $unsorted_tmp_filelist > $r_tmp_filelist");
    }

    # Remove the temporary unsorted file since we do not need it anymore.

    unlink($unsorted_tmp_filelist);

    # Return the status and the name of the sorted file containing the list of file names found.

    return($r_status, $r_tmp_filelist);
}
