#!/usr/local/bin/perl
#  Copyright 2016, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

# Subroutine saves the just combined file final destination for interprocess communication
# If sub-processes are running in parallel, the final location of the created files are not known to the parent process.
# By saving this filename along with some processing statistics to disk or memory, the parent process can be assured that the file was created successfully.

$GHRSST_PERL_LIB_DIRECTORY = $ENV{GHRSST_PERL_LIB_DIRECTORY};

do "$GHRSST_PERL_LIB_DIRECTORY/check_combined_file_final_location_historical.pl";

use File::Basename;
use File::Copy;

#------------------------------------------------------------------------------------------------------------------------
sub write_child_pipe_for_interprocess_communication_historical {

    # Write the file name along with some processing statistics of the just created file to the pipe created to communicate with the parent process.

    my $i_pipe_writer         = shift;
    my $i_scratch_area        = shift;
    my $i_output_directory    = shift;
    my $i_processing_type     = shift;
    my $i_name_only           = shift;
    my $i_file_extension      = shift;
    my $i_time_start_one_file_combining    = shift;
    my $i_time_stop_one_file_combining     = shift; 
    my $i_time_spent_one_file_in_combining = shift;
    my $i_batch_size                       = shift;
    my $i_input_directory_size             = shift;
    my $i_number_of_loops_to_run           = shift;
    my $i_loop_count                       = shift;
    my $i_num_files_read                   = shift;
    my $i_time_duration_uncompress         = shift;
    my $i_total_Bytes_in_files             = shift;

    my $debug_module = "write_child_pipe_for_interprocess_communication_historical:";
    my $debug_mode   = 0;

    # Verify that the combined file was created successfully.

    my ($o_file_created_successfully_flag,$o_final_location_historical,$o_actual_file_to_look) = check_combined_file_final_location_historical($i_output_directory,
                                                                                                                                               $i_processing_type,
                                                                                                                                               $i_file_extension,
                                                                                                                                               $i_name_only);
    if ($debug_mode) {
        print $debug_module . "o_file_created_successfully_flag [$o_file_created_successfully_flag] o_final_location_historical [$o_final_location_historical]\n";
    }

    if ($o_file_created_successfully_flag) {
        my $size_of_combined_file_in_bytes = (stat($o_final_location_historical))[7];
        my $current_time_in_epoch = time();

        # If the pipe is available, write the file name and some metadata about processing.
        if (defined($i_pipe_writer)) {
            # Format a few variables so the print widths are the same.
            my $formatted_spent_in_combining = sprintf("%06d",$i_time_spent_one_file_in_combining);
            my $formatted_time_duration_uncompress =  sprintf("%06d",$i_time_duration_uncompress);

            # Write to the pipe.
            print $i_pipe_writer "$o_final_location_historical $size_of_combined_file_in_bytes $current_time_in_epoch $formatted_spent_in_combining $i_time_start_one_file_combining $i_time_stop_one_file_combining $i_batch_size $i_input_directory_size $i_number_of_loops_to_run $i_loop_count $i_num_files_read $formatted_time_duration_uncompress $i_total_Bytes_in_files\n";

            # Save the status of the print statement above from the $! variable.  It should be an empty string if successful.
            my $write_status = $!;

            # Check the status of the previous write.  If it is not an empty string, then there is a issue. 
            if ($write_status ne "") {
                log_this("ERROR",$debug_module,"INTERPROCESS_COMMUNICATION_FAIL_WRITE: WRITE_STATUS [" . $write_status . "]");
                log_this("ERROR",$debug_module,"INTERPROCESS_COMMUNICATION_FAIL_WRITE: $o_final_location_historical $size_of_combined_file_in_bytes $current_time_in_epoch $formatted_spent_in_combining $i_time_start_one_file_combining $i_time_stop_one_file_combining $i_batch_size $i_input_directory_size $i_number_of_loops_to_run $i_loop_count $i_num_files_read $formatted_time_duration_uncompress $i_total_Bytes_in_files");
            } else {
                if ($debug_mode) {
                    log_this("INFO",$debug_module,"INTERPROCESS_COMMUNICATION_SUCCESS_WRITE: $o_final_location_historical $size_of_combined_file_in_bytes $current_time_in_epoch $formatted_spent_in_combining $i_time_start_one_file_combining $i_time_stop_one_file_combining $i_batch_size $i_input_directory_size $i_number_of_loops_to_run $i_loop_count $i_num_files_read $formatted_time_duration_uncompress $i_total_Bytes_in_files");
                }
            }
        } else {
            log_this("INFO",$debug_module,"WARN:CANNOT_SAVE_COMBINED_FILE_LOCATION_TO_PIPE_FOR_COMMUNICATION_PIPE_UNDEFINED.");
        }
    } else {
        log_this("INFO",$debug_module,"WARN: Cannot find file $o_final_location_historical and cannot save name to pipe for communication with the parent process");
    }
}

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    # my $now_is = localtime;

    # print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";

    print $i_function_name . " - " . $i_log_type . ": " . $i_log_message . "\n";
}
