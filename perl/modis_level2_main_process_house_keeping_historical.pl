#!/usr/local/bin/perl
#  Copyright 2016, by the California Institute of Technology.  ALL RIGHTS
#  RESERVED. United States Government Sponsorship acknowledged. Any commercial
#  use must be negotiated with the Office of Technology Transfer at the
#  California Institute of Technology.
#
# $Id$
# DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

#------------------------------------------------------------------------------------------------
# This is a one-off function to do some house keeping in the main process when doing parallel processing.
# Some of the function names start with "main_process_only_" so as to not disrupt the other functions with similiar names.

use File::Basename;
use File::Copy;

#------------------------------------------------------------------------------------------------------------------------
sub modis_level2_main_process_house_keeping_historical {
    my $i_run_log_for_interprocess_communication_historical_ref = shift;

    # Get the references of array variables.
    my %run_log_for_interprocess_communication_historical = %$i_run_log_for_interprocess_communication_historical_ref;

    my $o_total_Bytes_created_files  = 0; 
    my $o_num_combined_files_created = 0; 
    my $o_num_files_read             = 0;  # This is a dummy for now since we don't know how many files were read in creating the combined file.
    my $o_total_time_combining_jobs  = 0;
    my $o_total_time_stage_files     = 0;
    my $o_total_bytes_in_file        = 0;

    my $debug_module = "modis_level2_main_process_house_keeping_historical:";
    my $routine_name = "modis_level2_main_process_house_keeping_historical";
    my $debug_mode   = 0;

    if ($debug_mode) {
        my $hash_size = keys %run_log_for_interprocess_communication_historical;
        print $debug_module . "INTERPROCESS_COMMUNICATION HASH_SIZE $hash_size\n";
    }

    keys %run_log_for_interprocess_communication_historical; # Reset the internal iterator so a prior each() doesn't affect the loop.

    # Each original line of the file for interprocess communication look like below:
    #
    # /data/dev/scratch/qchau/scratch/AQUA_REFINED/2015/215/refined_A2015215003000.LAC_GSSTD.nc 68762852 1463603212 000009 1463603203 1463603212 2 6 2 2 3 000001 65544644
    # /data/dev/scratch/qchau/scratch/AQUA_REFINED/2015/215/refined_A2015215012000.LAC_GSSTD.nc 68762852 1463603212 000008 1463603204 1463603212 2 6 2 2 3 000001 70879547
    # /data/dev/scratch/qchau/scratch/AQUA_REFINED/2015/215/refined_A2015215012000.LAC_GSSTN.nc 71513743 1463603204 000008 1463603196 1463603204 2 6 1 2 3 000001 70879547
    # /data/dev/scratch/qchau/scratch/AQUA_REFINED/2015/215/refined_A2015215003000.LAC_GSSTN.nc 71513743 1463603203 000008 1463603195 1463603203 2 6 1 2 3 000001 65544644
    #
    #                                                                                 index     0        1          2      3          4          5 6 7 8 9 10     11
    #
    # The first column is saved in the hash table as the key and the rest of the line is saved as the value.
    # So we split the $combined_info into @tokens and then fetch each value individually.
    #
    # Indices and their meaning:
    #
    # Index 0 = file size
    # Index 1 = current time in seconds since 1970
    # Index 2 = number of seconds took to create the combined file
    # Index 3 = start time of combiner
    # Index 4 = end time of combiner
    # Index 5 = batch size
    # Index 6 = input directory size
    # Index 7 = loop count index (either 1 or 2)
    # Index 8 = number of loops to run (either 1 or 2)
    # Index 9 = number of files read (Actual number of files read if loop count index is the same as number of loops to run)
    # Index 10 = number of seconds took to stage (copy or move) the input file to scratch area.
    # Index 11 = total number of bytes from index 9 (the number of files read)

    my $FILE_SIZE_TOKEN_INDEX        = 0;
    my $COMBINED_TIME_INDEX          = 2;
    my $LOOP_COUNT_INDEX             = 7;
    my $NUMBER_OF_LOOPS_TO_RUN_INDEX = 8;
    my $NUM_FILES_READ_INDEX         = 9;
    my $STAGE_TIME_INDEX             = 10;
    my $TOTAL_BYTES_IN_FILE_INDEX    = 11;

    my $loop_count_index        = 0;
    my $number_of_loops_to_run  = 0;
    my $num_files_read          = 0;
    my $total_time_stage_files  = 0;
    my $total_bytes_in_file     = 0;

    while(my($combined_filename, $combined_info) = each %run_log_for_interprocess_communication_historical) {
        if ($debug_mode) {
            print $debug_module . "combined_filename [$combined_filename] combined_info [$combined_info]\n";
        }
        # FILE_SIZE_TOKEN_INDEX = 0;
        my @tokens = split /\s/, $combined_info;

        # Keep track of the sizes of each file combined for the total.
        $o_total_Bytes_created_files = $o_total_Bytes_created_files + int($tokens[$FILE_SIZE_TOKEN_INDEX]);
        # Keep track of how much time spent in each file.

        $o_total_time_combining_jobs  = $o_total_time_combining_jobs + int($tokens[$COMBINED_TIME_INDEX]);

        # Keep track of how many files combined.
        $o_num_combined_files_created += 1;

        # Get the loop_count_index, number_of_loops_to_run, and num_files_read with the next 3 tokens.
        $loop_count_index       = int($tokens[$LOOP_COUNT_INDEX]);
        $number_of_loops_to_run = int($tokens[$NUMBER_OF_LOOPS_TO_RUN_INDEX]);
        $num_files_read         = int($tokens[$NUM_FILES_READ_INDEX]);  # This is the number of files read for each granule.

        # Get the stage time for each granule in the next token.
        $total_time_stage_files = int($tokens[$STAGE_TIME_INDEX]);

        # Get the total_bytes_in_file for each granule in the next token. 
        $total_bytes_in_file    = int($tokens[$TOTAL_BYTES_IN_FILE_INDEX]);

        # The logic below is somewhat tricky.  We only increment o_num_files_read if the loop_count_index and number_of_loops_to_run are the same,
        # since the value of num_files_read represent the number of files read to create the day and night combined files: SST, SST4, OC
        # Same logic goes for increment o_total_time_stage_files and o_total_bytes_in_file variables.

        if ($loop_count_index == $number_of_loops_to_run)  {
            $o_num_files_read         = $o_num_files_read + $num_files_read;
            $o_total_time_stage_files = $o_total_time_stage_files + $total_time_stage_files;
            $o_total_bytes_in_file    = $o_total_bytes_in_file + $total_bytes_in_file;
        }
    }

    return($o_num_combined_files_created,
           $o_num_files_read,
           $o_total_time_combining_jobs,
           $o_total_Bytes_created_files,
           $o_total_time_stage_files,
           $o_total_bytes_in_file);
}

# End of modis_level2_main_process_house_keeping_historical suborutine here.
# Everything after this line are subroutines.

#------------------------------------------------------------------------------------------------------------------------
sub log_this {
    # Function to log a message to screen.
    my $i_log_type      = shift;  # Possible types are {INFO,WARN,ERROR}
    my $i_function_name = shift;  # Where the logging is coming from.  Useful in debuging if something goes wrong.
    my $i_log_message   = shift;  # The text you wish to log screen.

    my $now_is = localtime;

    print $now_is . " " . $i_log_type . " [" . $i_function_name . "] " . $i_log_message . "\n";
}
