;  Copyright 2014, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

FUNCTION find_netcdf_variable_attribute_info,$
         i_attribute_to_find,$
         i_attributes_array,$
         o_attribute_value

; Function returns a variable attribute given a variable name and the array containing a list of attributes.
; If i_attribute_to_find is not defined or empty string, function will return an empty string.
; The i_attributes_array containg an array of strings:
;
; 'scale_factor|FLOAT|0.000200000'
; 'add_offset|FLOAT|0.00000'
; 'long_name|STRING|Diffuse'
; 'units|STRING|m^-1'
; 'flag_mask_short_without_marker_space_separator|SHORT|1 2 3 4 5 6'
; 'flag_mask_long_without_marker_space_separator|LONG|1 2 3 4 5'
;
; Assumptions/Notes:
;
;   1. FLOAT attribute type is treated as a scalar.
;   2. If the i_attribute_to_find is not found in i_attributes_array, an emptr string will be returned.
;      so becareful to specify the correct value for i_attribute_to_find.
;

;------------------------------------------------------------------------------------------------

; Load constants.

@data_const_config.cfg

; Define local variables.

o_read_status = SUCCESS;
debug_flag = 0;

; Get the DEBUG_MODE if it is set.

debug_module = 'find_netcdf_variable_attribute_info:';
if (STRUPCASE(GETENV('GHRSST_MODIS_L2_COMBINER_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_flag = 1;
endif

;debug_flag = 1;

; Set default return value.
; This is a design decision: to return an empty string instead of an undefined value.  The function
; that calls this, must do a check for empty string instead of an undefined value.

o_attribute_value = '';  This can be anything from string to float, to double, to byte.

array_index = 0;
found_variable_name_flag = 0;

if (debug_flag) then begin
    print, debug_module + 'i_attribute_to_find    [', i_attribute_to_find , ']';
endif

while (array_index LT  N_ELEMENTS(i_attributes_array)) AND (found_variable_name_flag EQ 0) do begin
    if (debug_flag) then begin
        print, debug_module + 'INSPECTING_ATTRIBUTES_ARRAY ' + i_attributes_array[array_index];
    endif

    ; Do a sanity check to see that the string is not an empty string.  Exit this loop if found one.
    if (STRLEN(i_attributes_array[array_index]) LE 0) then BREAK; 

    splitted_tokens = STRSPLIT(i_attributes_array[array_index],'|', /EXTRACT);
    ; The format is:
    ;      long_name|BYTE|Sea Surface Temperature
    ;      scale_factor|FLOAT|0.00500000 

    attribute_name = splitted_tokens[0];
    attribute_type = splitted_tokens[1];

    if (N_ELEMENTS(splitted_tokens) LE 2) then begin
        raw_attribute_value = ' ';
    endif else begin
        raw_attribute_value = splitted_tokens[2];
    endelse

    if (debug_flag) then begin
        print, debug_module + 'splitted_tokens[0] [', splitted_tokens[0] , ']';
        print, debug_module + 'splitted_tokens[1] [', splitted_tokens[1] , ']';
    endif
    if (i_attribute_to_find EQ attribute_name) then begin
        if (attribute_type EQ "BYTE") then begin
            ; If the attribute is among these expected names, we treat them differenly by converting to string all the characters, i.e long_name|BYTE|Level-2 Processing Flags
            if (((attribute_name EQ 'long_name')     OR (attribute_name EQ 'units')) OR $ 
                 (attribute_name EQ 'standard_name') OR (attribute_name EQ 'flag_meanings')) then begin 
                o_attribute_value = STRING(raw_attribute_value);
            endif else begin
                o_attribute_value = parse_attribute_array(i_attribute_to_find,attribute_type,raw_attribute_value);
            endelse
        endif
        ; For now, FLOAT attribute type is treated as a scalar.
        if (attribute_type EQ "FLOAT") then begin
            o_attribute_value = FLOAT(raw_attribute_value);
        endif
        if (attribute_type EQ "LONG") then begin
            ; For now, any attribute name containing 'flag' is treated as an array of values.
            if (STRPOS(attribute_name,'flag') GE 0) then begin
                o_attribute_value = parse_attribute_array(i_attribute_to_find,attribute_type,raw_attribute_value);
            endif else begin
                o_attribute_value = LONG(raw_attribute_value);
            endelse

        endif
        if (attribute_type EQ "INT") OR (attribute_type EQ "SHORT") then begin
            ; For now, any attribute name containing 'flag' is treated as an array of values.
            if (STRPOS(attribute_name,'flag') GE 0) then begin
                o_attribute_value = parse_attribute_array(i_attribute_to_find,attribute_type,raw_attribute_value);
            endif else begin
                o_attribute_value = FIX(raw_attribute_value);
            endelse
        endif
        if (attribute_type EQ "STRING") then begin
            o_attribute_value = STRING(raw_attribute_value);
        endif
        ; Indicate that we have found the flag, no longer need to look.
        found_variable_name_flag = 1;
    endif
    array_index++;
endwhile

; Print a warning if cannot found the i_attribute_to_find in any of the strings.

if (found_variable_name_flag EQ 0) AND (debug_flag) then begin
    print, debug_module + 'WARN: Cannot find i_attribute_to_find  [' + i_attribute_to_find + '] among the strings in i_attributes_array.';
endif

if (debug_flag) then begin
    print, debug_module + 'i_attribute_to_find   [', i_attribute_to_find, ']';
    print, debug_module + 'o_attribute_value [', o_attribute_value , ']';
    print, debug_module + 'SIZE(o_attribute_value,/TNAME) [', SIZE(o_attribute_value,/TNAME) , ']';
endif

; ---------- Close up shop ---------- 
return, o_read_status;
end
