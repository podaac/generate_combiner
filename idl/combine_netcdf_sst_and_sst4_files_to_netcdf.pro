;  Copyright 2015, by the California Institute of Technology.  ALL RIGHTS
;  RESERVED. United States Government Sponsorship acknowledged. Any commercial
;  use must be negotiated with the Office of Technology Transfer at the
;  California Institute of Technology.
;
; $Id$
; DO NOT EDIT THE LINE ABOVE - IT IS AUTOMATICALLY GENERATED BY CM

PRO combine_netcdf_sst_and_sst4_files_to_netcdf,$
             i_sst_filename,$
             i_sst4_filename,$
             i_oc_filename,$
             i_out_filename,$
             i_when_processed_parameter

; Program to combine the SST, SST4 and OC files into one file.  This program is different than combine_sst_and_sst4_files.pro in that the 
; input files are NetCDF format instead of HDF format.  This change is initiated by OBPG to go from HDF to NetCDF format.
; Note that the variables are now inside a group.  The function read_netcdf_one_variable() will take care of the variable reading.
;
; This program can support combine an HDF version of the SST4/OC file if that is the case.  It makes the distinction of file type based on the file extension.
; NetCDF file has .nc as the file extension.
;
; Assumptions:
;
;   1. If the name of SST4 file is "DUMMY_SST4_FILENAME", we assume that it is not meant as a valid file.
;   2. If the name of OC   file is "DUMMY_OC_FILENAME",   we assume that it is not meant as a valid file.
;
; Notes:
;
;   1. August 2014: A major revamp of error handling added.  Whenever an error occur with 
;
;        - finding input file
;        - creating the output file
;        - reading a variable
;        - writing a variable
;
;     a message will echoed to screen, loggged to error file, input file(s) quarantine and output file deleted (if it has been created already).  The Perl framework which calls this program
;     will then look for an output file and it won't be found which will cause an ERROR sigevent to be raised.  The operator can then look in the log file to see the exact reason
;     for the error.  Previous implementation raise sigevents in IDL and perl and left the output file to remain to become input to MODIS L2P Processing which will then
;     raise other unnecessary sigevents.
;
;   2. August 2014: Hooks were added into this program to allow developer to inject different errors.  The environment setting of each variable can be set to "true" to
;      cause certain error status to be set, which will trigger the error handling.  See bin/run_combiner_error_handling_tests.csh C-shell file for how the error handlings tests are initiated.
;
;   3. The variable i_out_filename will be appended with .LAC_GSSTD.nc or .LAC_GSSTN.nc and can be available to code calling this program.

;------------------------------------------------------------------------------------------------

; Load constants.

@modis_data_config.cfg

; Define local variables.

r_status = SUCCESS;

args = COMMAND_LINE_ARGS(COUNT = argCount);

IF argCount EQ 0 THEN BEGIN
        ;PRINT, 'process_modis_datasets:No input arguments specified'
        ;RETURN
ENDIF ELSE BEGIN
    i_sst_filename  = args[0];
    i_sst4_filename = args[1];
    i_oc_filename   = args[2];
    i_out_filename  = args[3];
    i_when_processed_parameter = args[4];
ENDELSE

routine_name = "combine_netcdf_sst_and_sst4_files_to_netcdf:";
debug_module = "combine_netcdf_sst_and_sst4_files_to_netcdf:";
msg_type = "";
i_data = "";

; Get the DEBUG_MODE if it is set.

debug_module = 'combine_netcdf_sst_and_sst4_files_to_netcdf:';
debug_mode = 1

if (STRUPCASE(GETENV('GHRSST_MODIS_L2_COMBINER_DEBUG_MODE')) EQ 'TRUE') then begin
    debug_mode = 1;
endif

combiner_start = SYSTIME(/SECONDS);
combiner_start_date = SYSTIME();
print, debug_module + 'COMBINER_START ' + combiner_start_date;

; Return if file does not exist.

file_exist = FILE_TEST(i_sst_filename);

if (GETENV('GHRSST_MODIS_COMBINER_INPUT_FILE_NOT_FOUND_TEST') EQ 'true') then file_exist = 0;

if (file_exist EQ 0) then begin
    r_status = FILE_NOT_FOUND_STATUS;
    msg_type = "error";
    msg = "File not found: " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    exit, status=49   ; Indicate an error that should prompt notification
endif

; List of LONG global attributes to read from NetCDF file.
; Note that the first 2 attributes are lower case since in the new NetCDF file has these attributes in lower case only.
; The other attributes will be calculated separatedly.

long_attributes_names = [$
                          'scan_control_points', $
                          'pixel_control_points',$
                          'Start Year',          $
                          'Start Day',           $
                          'Start Millisec',      $
                          'End Year',          $
                          'End Day',           $
                          'End Millisec']

; Array to store these LONG values.  Note that this cannot be used to read character variables.

long_attributes_values = LONARR(8);  We need 2 for scan_control_points and pixel_control_points and 3 for year, day and start millisec and 3 for end year, end day, end millisec.

; List of indices to global_variable_values array.

Number_of_Scan_Lines_index = 0;
Pixels_per_Scan_Line_index = 1;
Start_Year_index           = 2;
Start_Day_index            = 3;
Start_Millisec_index       = 4;
End_Year_index             = 5;
End_Day_index              = 6;
End_Millisec_index         = 7;

;
; Read only the 2 first the LONG global attributes.  We will calculate the rest from other variables since
; the NetCDF file no longer have these attributes in the global attribute section but in the variable section.
;

for i = 0, 1 do begin

    ; Read one attribute at a time.
    r_status = read_netcdf_global_attribute(i_sst_filename,long_attributes_names[i],r_long_attribute_value);

    if (GETENV('GHRSST_MODIS_COMBINER_FAILED_READ_LONG_ATTRIBUTE_TEST') EQ 'true') then r_status = FAILURE

    ; The reprocessed 2002 files may not have these global attributes.  We have to look elsewhere in the file.
    if (r_status NE SUCCESS)then begin
        if (long_attributes_names[i] EQ 'scan_control_points') then begin
            ; The name of the dimension is 'number_of_lines' instead of 'scan_control_points' so we use 'number_of_lines' to look for the dimension value.
            r_status = get_netcdf_dimension(i_sst_filename,$
                                            'number_of_lines',$
                                             r_long_attribute_value);
        endif
        if (long_attributes_names[i] EQ 'pixel_control_points') then begin
            r_status = get_netcdf_dimension(i_sst_filename,$
                                            'pixel_control_points',$
                                             r_long_attribute_value);
            if (r_status NE SUCCESS)then begin
                r_status = get_netcdf_dimension(i_sst_filename,$
                                            'pixels_per_line',$
                                             r_long_attribute_value);
            endif
        endif
    end

    if (r_status NE SUCCESS) then begin
        msg_type = "error";
        msg = "[DEBUGGING] Cannot read global attribute " + long_attributes_names[i] + " from file " + i_sst_filename;
        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);
        ; Must return immediately.
        exit, status=49   ; Indicate an error that should prompt notification
    endif

    ; Save it in the array.

    long_attributes_values[i] = r_long_attribute_value;

    ; Do a sanity check on these attributes to see that they are not equal to zero:
    ;     'scan_control_points'
    ;     'pixel_control_points'
    ;     'Start Year'
    ;     'Start Day'
    ;     'Start Millisec'
    ;     'End Year'
    ;     'End Day'
    ;     'End Millisec'

    if ((GETENV('GHRSST_MODIS_COMBINER_BAD_SCAN_CONTROL_POINTS_TEST')      EQ 'true') AND (i EQ Number_of_Scan_Lines_index)) then long_attributes_values[i] = 0;
    if ((GETENV('GHRSST_MODIS_COMBINER_BAD_PIXEL_CONTROL_POINTS_TEST')     EQ 'true') AND (i EQ Pixels_per_Scan_Line_index)) then long_attributes_values[i] = 0;

    if ((((long_attributes_names[i] EQ 'Start Year') OR (long_attributes_names[i] EQ 'Start Day') OR (long_attributes_names[i] EQ 'Start Millisec')) OR    $
        ((long_attributes_names[i] EQ 'End Year')    OR (long_attributes_names[i] EQ 'End Day')   OR (long_attributes_names[i] EQ 'End Millisec')))  OR    $
        ((long_attributes_names[i] EQ 'scan_control_points') OR (long_attributes_names[i] EQ 'pixel_control_points'))                             AND  $
        (long_attributes_values[i] LE 0)) then begin

        msg_type = "error";
        msg = "Cannot read global attribute " + long_attributes_names[i] + " contains bad value " + STRTRIM(STRING(long_attributes_values[i]),2) + " from file " + i_sst_filename;

        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);

        ; No need to keep going.  Exiting now.
        exit, status=49   ; Indicate an error that should prompt notification;
    endif

    if (debug_mode) then begin
        print, routine_name,"long_attributes_names[", i, "] = [",long_attributes_values[i], "]";
    endif

endfor

;
; The "year" and "day" were in the global attributes in the HDF file.  They are now in the "year" variable in the "scan_line_attributes" group.
;

i_variable_short_name = 'year';
r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_START_YEAR_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
; For some reason,  some of the test files from 2007 does not have scale_factor and add_offset.
; If the value are provided, we will use them.

if (ISA(r_slope,/NUMBER) AND ISA(r_intercept,/NUMBER)) then begin
    start_year = FIX(r_dataset_array[0] * r_slope + r_intercept);
    if (debug_mode) then begin
        print, routine_name,'Variable r_slope and r_intercept are numbers';
        print, routine_name,'r_slope = ', r_slope;
        print, routine_name,'r_intercept = ', r_intercept;
    endif
endif else begin
    start_year = FIX(r_dataset_array[0]);
    if (debug_mode) then begin
        print, routine_name,'Variable r_slope and r_intercept are not numbers.  Take the start year value as is from r_dataset_array[0] ', r_dataset_array[0];
    endif
endelse
if (debug_mode) then begin
    print, routine_name, "start_year = ",start_year;
endif

; Do a sanity check on the year. It should be greater than 1900.

if (GETENV('GHRSST_MODIS_COMBINER_BAD_START_YEAR_ATTRIBUTE_TEST')     EQ 'true') then start_year = 0;

if (start_year LT 1900) then begin
    msg_type = "error";
    msg = "Cannot read attribute year due to value not greater than or equal to 1900 in file " + i_sst_filename + ".  Current value " + STRTRIM(STRING(start_year),2);
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

i_variable_short_name = 'day';
r_status = read_netcdf_one_variable(i_sst_filename,$
                                     i_variable_short_name,$
                                     o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_START_DAY_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);

    status = FAILURE;
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
; For some reason,  some of the test files from 2007 does not have scale_factor and add_offset.
; If the value are provided, we will use them.
if (ISA(r_slope,/NUMBER) AND ISA(r_intercept,/NUMBER)) then begin
    start_day  = FIX(r_dataset_array[0] * r_slope + r_intercept);
endif else begin
    start_day  = FIX(r_dataset_array[0]);
endelse
if (debug_mode) then begin
    print, routine_name,"start_day = ",start_day;
endif

; Do a sanity check on the day. It should be between 1 and 366

if (GETENV('GHRSST_MODIS_COMBINER_BAD_START_DAY_ATTRIBUTE_TEST')      EQ 'true') then start_day = 0;

if ((start_day LT 1) OR (start_day GT 366)) then begin
    msg_type = "error";
    msg = "Cannot read attribute day due to value not in between 1 and 366 in file " + i_sst_filename + ".  Current value " + STRTRIM(STRING(start_day),2);
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);

    status = FAILURE;
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Save the year and day into the long array so they can be written to output file.

long_attributes_values[Start_Year_index] = start_year;
long_attributes_values[Start_Day_index]  = start_day;

;
; Save most used global attributes.
;

num_lons = long_attributes_values[Number_of_Scan_Lines_index]; Typically 2030 but can be smaller if the measurements are less than 5 minutes.  
num_lats = long_attributes_values[Pixels_per_Scan_Line_index]; Typically 1354

;
; List of FLOAT global attributes to read from NetCDF file.
; Note again that they are all lowercase instead of uppercase as the case of HDF file.

float_attributes_names = ['northernmost_latitude',$
                          'southernmost_latitude',$
                          'easternmost_longitude',$
                          'westernmost_longitude'];

; List of indices to float_attributes_names array.

Northernmost_Latitude_index = 0;
Southernmost_Latitude_index = 1;
Easternmost_Longitude_index = 2; 
Westernmost_Longitude_index = 3;

; Array to store these FLOAT values.  Note that this cannot be used to read character variables.

float_attributes_values = FLTARR(size(float_attributes_names,/N_ELEMENTS));

;
; Read all the FLOAT global attributes.
;

for i = 0, (size(float_attributes_values,/N_ELEMENTS) - 1) do begin

    ; Read one attribute at a time.
    r_status = read_netcdf_global_attribute(i_sst_filename,float_attributes_names[i],r_float_attribute_value);

    if ((GETENV('GHRSST_MODIS_COMBINER_FAILED_NORTHERNMOST_LATITUDE_ATTRIBUTE_READ_TEST') EQ 'true') AND (i EQ Northernmost_Latitude_index)) then r_status = FAILURE;
    if ((GETENV('GHRSST_MODIS_COMBINER_FAILED_SOUTHERNMOST_LATITUDE_ATTRIBUTE_READ_TEST') EQ 'true') AND (i EQ Southernmost_Latitude_index)) then r_status = FAILURE;
    if ((GETENV('GHRSST_MODIS_COMBINER_FAILED_EASTERNMOST_LONGITUDE_ATTRIBUTE_READ_TEST') EQ 'true') AND (i EQ Easternmost_Longitude_index)) then r_status = FAILURE;
    if ((GETENV('GHRSST_MODIS_COMBINER_FAILED_WESTERNMOST_LONGITUDE_ATTRIBUTE_READ_TEST') EQ 'true') AND (i EQ Westernmost_Longitude_index)) then r_status = FAILURE;

    if (r_status NE SUCCESS) then begin
        msg_type = "error";
        msg = "[DEBUGGING 2] Cannot read global attribute " + float_attributes_names[i] + " from file " + i_sst_filename;
        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);
        ; Must return immediately.
        exit, status=49   ; Indicate an error that should prompt notification
    endif

    ; Do a sanity check on the value of northernmost_latitude that it is within the globe: GT 90.0 OR LT -90.0

    if (i EQ Northernmost_Latitude_index) then begin
        if ((r_float_attribute_value GT 90.0) OR (r_float_attribute_value LT -90.0)) then begin
            msg_type = "error";
            msg = "Cannot read global attribute " + float_attributes_names[i] + " from file " + i_sst_filename + " due to outside of the globe value " + STRING(r_float_attribute_value);;
            donotcare = echo_message_to_screen(routine_name,msg,msg_type);
            donotcare = error_log_writer(routine_name,msg);
            ; Must return immediately.
            exit, status=49   ; Indicate an error that should prompt notification
        endif
    endif

    ; Do a sanity check on the value of southernmost_latitude that it is within the globe: GT 90.0 OR LT -90.0 

    if (i EQ Southernmost_Latitude_index) then begin 
        if ((r_float_attribute_value GT 90.0) OR (r_float_attribute_value LT -90.0)) then begin
            msg_type = "error";
            msg = "Cannot read global attribute " + float_attributes_names[i] + " from file " + i_sst_filename + " due to outside of the globe value " + STRING(r_float_attribute_value);;
            donotcare = echo_message_to_screen(routine_name,msg,msg_type);
            donotcare = error_log_writer(routine_name,msg);
            ; Must return immediately.
            exit, status=49   ; Indicate an error that should prompt notification
        endif
    endif 

    ; Do a sanity check on the value of easternmost_longitude that it is within the globe: GT 180.0 OR LT -180.0 

    if (i EQ Easternmost_Longitude_index) then begin 
        if ((r_float_attribute_value GT 180.0) OR (r_float_attribute_value LT -180.0)) then begin
            msg_type = "error";
            msg = "Cannot read global attribute " + float_attributes_names[i] + " from file " + i_sst_filename + " due to outside of the globe value " + STRING(r_float_attribute_value);;
            donotcare = echo_message_to_screen(routine_name,msg,msg_type);
            donotcare = error_log_writer(routine_name,msg);
            ; Must return immediately.
            exit, status=49   ; Indicate an error that should prompt notification
        endif
    endif 

    ; Do a sanity check on the value of westernmost_longitude that it is within the globe: GT 180.0 OR LT -180.0 

    if (i EQ Westernmost_Longitude_index) then begin 
        if ((r_float_attribute_value GT 180.0) OR (r_float_attribute_value LT -180.0)) then begin
            msg_type = "error";
            msg = "Cannot read global attribute " + float_attributes_names[i] + " from file " + i_sst_filename + " due to outside of the globe value " + STRING(r_float_attribute_value);;
            donotcare = echo_message_to_screen(routine_name,msg,msg_type);
            donotcare = error_log_writer(routine_name,msg);
            ; Must return immediately.
            exit, status=49   ; Indicate an error that should prompt notification
        endif
    endif 

    ; Save the value in our float_attributes_values array.
    float_attributes_values[i] = FLOAT(r_float_attribute_value);

    if (debug_mode) then begin
        print, routine_name,'r_float_attribute_value = ', r_float_attribute_value;
    endif

endfor

; Do a sanity check on the values of southernmost_latitude and northernmost_latitude together: southernmost_latitude GT northernmost_latitude

if (float_attributes_values[Southernmost_Latitude_index] GT float_attributes_values[Northernmost_Latitude_index]) then begin
    msg_type = "error";
    msg = "Cannot read global attributes southernmost_latitude and northernmost_latitude due to swap_lats values from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Do a sanity check on the values of westernmost_longitude and easternmost_longitude together: westernmost_longitude GT easternmost_longitude
; For now, commented out since the test of checking westernmost_longitude against easternmost_longitude below is not true for bad value.

;if (float_attributes_values[Westernmost_Longitude_index] GT float_attributes_values[Easternmost_Longitude_index]) then begin
;    msg_type = "error";
;    msg = "Cannot read global attributes westernmost_longitude and easternmost_longitude due to swap_lon values rom file " + i_sst_filename;
;    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
;    donotcare = error_log_writer(routine_name,msg);
;    status = FAILURE;
;    ; Must return immediately.
;    return
;endif

;
; Allocate enough room to hold all the string attributes:
;

string_attributes_names  = STRARR(6);
string_attributes_values = STRARR(6);
string_index = 0;

;
; Read all the string global attributes the start time and end time as strings.  Must convert them to seconds.
;

i_attribute_name = 'time_coverage_start';
r_status = read_netcdf_global_attribute(i_sst_filename,i_attribute_name,r_start_time);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_TIME_COVERAGE_START_ATTRIBUTE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "[DEBUGGING 3] Cannot read global attribute " + i_attribute_name + " from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

;
; Do a sanity check to make sure the field time_coverage_start look valid.
;

o_time_field_valid_flag = validate_time_field($
                              i_attribute_name,$
                              r_start_time);

if (o_time_field_valid_flag NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read global attribute ' + i_attribute_name + ' due to invalid value ' + r_start_time + ' from file ' + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately. 
    exit, status=49   ; Indicate an error that should prompt notification
endif

string_attributes_names[string_index] = 'time_coverage_start'; 

; We delay saving this attribute since it is not in the correct format.
; We need to parse for the hour, minute, second and then multiply by 1000 to get to the milliseconds
; We need to keep track of the starting day so we can detect if the end day is different.

extract_time_fields_from_time_coverage_attribute,r_start_time,start_day_in_month,start_year,start_millisec;

; If the milliseconds are available, we attempt to fetch it.
;
;     2003-03-01T10:55:05.456Z
;     012345678901234567890123

;print, debug_module + 'pre add_optional_milliseconds_to_milliseconds_total(r_start_time,start_millisec)' 
;help, start_millisec;
start_millisec = add_optional_milliseconds_to_milliseconds_total(r_start_time,start_millisec);
;print, debug_module + 'pre add_optional_milliseconds_to_milliseconds_total(r_start_time,start_millisec)' 
;help, start_millisec

if (debug_mode) then begin
    print, routine_name,'time_coverage_start = ', r_start_time;
    print, routine_name,'start_millisec = ', start_millisec
    print, routine_name,'start_year     = ', start_year
endif

; Do a sanity check on the start_millisec value.

if (GETENV('GHRSST_MODIS_COMBINER_BAD_START_MILLISEC_ATTRIBUTE_TEST') EQ 'true') then start_millisec = -1;

if (start_millisec LT 0) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name +".  The computed value of start_millisec " + STRTRIM(STRING(start_millisec),2) + " from " + r_start_time + " is less than zero from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Save the start_millisec to long array so they can be written to output file.

long_attributes_values[Start_Millisec_index] = start_millisec;

; We cannot save the time_coverage_start as 2003-03-01T10:55:05Z
; since the format in our output file is 2003060105505
; We have to massage the format a bit before saving.

start_day_of_year = ""; 

; Prepends any necessary zeros to the start_day.
if (start_day LT 10) then begin
    start_day_of_year = '00' + STRTRIM(STRING(start_day),2);
endif
if ((start_day LT 100) && (start_day GE 10)) then begin
    start_day_of_year = '0' + STRTRIM(STRING(start_day),2);
endif
if (start_day GE 100) then begin
    start_day_of_year = STRTRIM(STRING(start_day),2);
endif

; Build the start time with the format 2003060105505

reformatted_start_time = STRTRIM(STRING(start_year),2)  + start_day_of_year + STRMID(r_start_time,11,2) + STRMID(r_start_time,14,2) + STRMID(r_start_time,17,2);
if (debug_mode) then begin
    print, routine_name, 'start_day_of_year = [', start_day_of_year, ']'
    print, routine_name, 'reformatted_start_time = [', reformatted_start_time, ']'
endif

; Finally, we can save the reformatted start time.
string_attributes_values[string_index]= reformatted_start_time; 
string_index = string_index + 1;

; Get the global attribute 'time_coverage_end' from file.

i_attribute_name = 'time_coverage_end';
r_status = read_netcdf_global_attribute(i_sst_filename,i_attribute_name,r_end_time);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_TIME_COVERAGE_END_ATTRIBUTE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "[DEBUGGING 4] Cannot read global attribute " + i_attribute_name + " from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

;
; Do a sanity check to make sure the field time_coverage_end look valid.
;

o_time_field_valid_flag = validate_time_field($
                              i_attribute_name,$
                              r_end_time);

if (o_time_field_valid_flag NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot read global attribute ' + i_attribute_name + ' due to invalid value ' + r_end_time + ' from file ' + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately. 
    exit, status=49   ; Indicate an error that should prompt notification
endif

string_attributes_names[string_index] = 'time_coverage_end'; 

; We have to delay saving the time_coverage_end until we can reformat the date.
; We need to parse for the hour, minute, second and then multiply by 1000 to get to the milliseconds
; We need to keep track of the end day so we can detect if the end day is different.

extract_time_fields_from_time_coverage_attribute,r_end_time,end_day_in_month,end_year,end_millisec;

; If the milliseconds are available, we attempt to fetch it.
;
;     2003-03-01T10:55:05.456Z
;     012345678901234567890123

end_millisec = add_optional_milliseconds_to_milliseconds_total(r_end_time,end_millisec);

if (debug_mode) then begin
    print, routine_name,'time_coverage_end = ', r_end_time;
    print, routine_name,'end_millisec = ', end_millisec;
    print, routine_name,'end_year = ', end_year;
endif

; Do a sanity check on the end_millisec value.

if (GETENV('GHRSST_MODIS_COMBINER_BAD_END_MILLISEC_ATTRIBUTE_TEST') EQ 'true') then end_millisec = -1;

if (end_millisec LT 0) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + ".  The computed value of end_millisec " + STRTRIM(STRING(end_millisec),2) + " from " + r_end_time + " is less than zero from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Save the end_millisec long array so they can be written to output file.

long_attributes_values[End_Millisec_index] = end_millisec;

if (debug_mode) then begin
    print, routine_name,'end_coverage_start = ', r_end_time;
    print, routine_name,'end_millisec = ', end_millisec
endif

; Do a sanity check on the end day in month value.

if (GETENV('GHRSST_MODIS_COMBINER_BAD_END_DAY_YEAR_ATTRIBUTE_TEST')   EQ 'true') then end_day_in_month = 0;

if (end_day_in_month LT 1) OR (end_day_in_month GT 31) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + ".  Attribute end_day_in_month extracted from " + r_end_time + " should be between 1 and 31 in file " + i_sst_filename + ".  Current value " + STRTRIM(STRING(end_day_in_month),2);
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; If the day in the month is different between start and end coverage means that we have skipped to the next day.
; Since a granule duration is only 5 minutes it is safe to assume that the day increment is only one day.

if (start_day_in_month EQ end_day_in_month) then begin
    end_day = long_attributes_values[Start_Day_index];
endif else begin
    ; Check to see if day of the month has gotten smaller, e.g. changed from 31 to 1
    ; and the year had increment by 1, we set the end_day to 1 to signify January 1, of next year.
    if ((end_day_in_month LT start_day_in_month) AND (end_year GT start_year)) then begin
        end_day = 1;
    endif else begin
        end_day = long_attributes_values[Start_Day_index] + 1;
    endelse
endelse

; Do a sanity check on the end_year value.
if (GETENV('GHRSST_MODIS_COMBINER_BAD_END_YEAR_ATTRIBUTE_TEST')       EQ 'true') then end_year = 1899;

if (end_year LT 1900) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + ".  Attribute end_year from " + r_end_time + " should be greater than or equal to 1900 in file " + i_sst_filename + ".  Current value " + STRTRIM(STRING(end_year),2);
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Now we can save the "End Year" and "End Day" value.

long_attributes_values[End_Year_index] = end_year;
long_attributes_values[End_Day_index]  = end_day;

; We cannot save the time_coverage_end as 2003-03-01T11:00:05Z 
; since the format in our output file is 2003060110005
; We have to massage the format a bit before saving.

end_day_of_year = ""; 

; Prepends any necessary zeros to the start_day.
if (end_day LT 10) then begin
    end_day_of_year = '00' + STRTRIM(STRING(end_day),2);
endif
if ((end_day LT 100) && (end_day GE 10)) then begin
    end_day_of_year = '0' + STRTRIM(STRING(end_day),2);
endif
if (end_day GE 100) then begin
    end_day_of_year = STRTRIM(STRING(end_day),2);
endif

reformatted_end_time = STRTRIM(STRING(end_year),2)  + end_day_of_year + STRMID(r_end_time,11,2) + STRMID(r_end_time,14,2) + STRMID(r_end_time,17,2);
if (debug_mode) then begin
    print, routine_name, 'end_day_of_year = [', end_day_of_year, ']'
    print, routine_name, 'reformatted_end_time = [', reformatted_end_time, ']'
endif

; Now we can save the reformatted end time.

string_attributes_values[string_index]= reformatted_end_time; 
string_index = string_index + 1;

;
; Read other string/character attributes.
;
i_attribute_name = 'instrument';
r_status = read_netcdf_global_attribute(i_sst_filename,i_attribute_name,r_sensor_name);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_INSTRUMENT_ATTRIBUTE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "[DEBUGGING 5] Cannot read global attribute " + i_attribute_name + " from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Do a sanity check on the 'instrument' attribute.  For now, we look to see if it contain modis (case not important).

if (STRMATCH(r_sensor_name,'*MODIS*',/FOLD_CASE) NE 1) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + " due to invalid value in file " + i_sst_filename + ".  Current value " + r_sensor_name;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

string_attributes_names[string_index] = 'instrument'; 
string_attributes_values[string_index]= r_sensor_name;
string_index = string_index + 1;
if (debug_mode) then begin
print, routine_name, 'r_sensor_name = ', r_sensor_name;
endif

i_attribute_name = 'startDirection';
r_status = read_netcdf_global_attribute(i_sst_filename,i_attribute_name,r_start_node);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_START_DIRECTION_ATTRIBUTE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "[DEBUGGING 6] Cannot read global attribute " + i_attribute_name + " from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Do a sanity check on the attribute.

if ((r_start_node NE 'Ascending') AND (r_start_node NE 'Descending')) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + " due to invalid value in file " + i_sst_filename + ".  Current value " + r_start_node;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

string_attributes_names[string_index] = 'startDirection'; 
string_attributes_values[string_index]= r_start_node
string_index = string_index + 1;

if (debug_mode) then begin
print, routine_name, 'r_start_node = ', r_start_node;
endif

i_attribute_name = 'endDirection';
r_status = read_netcdf_global_attribute(i_sst_filename,i_attribute_name,r_end_node);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_END_DIRECTION_ATTRIBUTE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "[DEBUGGING 7] Cannot read global attribute " + i_attribute_name + " from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Do a sanity check on the attribute.

if ((r_end_node NE 'Ascending') AND (r_end_node NE 'Descending')) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + " due to invalid value in file " + i_sst_filename + ".  Current value " + r_end_node;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);

    status = FAILURE;
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

string_attributes_names[string_index] = 'endDirection'; 
string_attributes_values[string_index]= r_end_node;
string_index = string_index + 1;
if (debug_mode) then begin
print, routine_name, 'r_end_node = ', r_end_node;
endif

i_attribute_name = 'day_night_flag';
r_status = read_netcdf_global_attribute(i_sst_filename,i_attribute_name,r_day_or_night);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_DAY_NIGHT_FLAG_ATTRIBUTE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "[DEBUGGING 8] Cannot read global attribute " + i_attribute_name + " from file " + i_sst_filename;

    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Remove the non-ascii character from variable.
r_day_or_night = convert_to_ascii_string(r_day_or_night);

; Do a sanity check on the attribute.

if ((r_day_or_night NE 'Day') AND $
   ((r_day_or_night NE 'Night') AND (r_day_or_night NE 'Mixed')) ) then begin
    msg_type = "error";
    msg = "Cannot read global attribute " + i_attribute_name + " due to invalid value in file " + i_sst_filename + ".  Current value " + r_day_or_night;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    ; Must return immediately.
    exit, status=49   ; Indicate an error that should prompt notification
endif

; Special processing:
;
; If the variable i_when_processed_parameter is passed in as 'D', we overwrite the r_day_or_night by setting it to 'Day'
; so that we can produce a Day file with a SST for Mixed.

if (i_when_processed_parameter EQ 'D') then begin
    r_day_or_night = 'Day';
endif

string_attributes_names[string_index] = 'day_night_flag'; 
string_attributes_values[string_index]= r_day_or_night;
string_index = string_index + 1;

; Now that we know if the file is day or night, we can name the output file.

directory_only         = ""; 
basename_only          = ""; 
name_without_extension = ""; 

if (debug_mode) then begin
    print, debug_module + 'i_out_filename = ' + ' ' + i_out_filename;
endif

; Do a sanity check if the name is AQUA_MODIS.2019289042500.L2.SST.nc or A2019289042500.L2_LAC_SST
; The OBPG 2019 naming pattern is L2.SST.nc or L2.SST
file_is_2019_naming_pattern = 0;
if ((STRPOS(i_sst_filename,"L2.SST") GE 0) OR (STRPOS(i_sst_filename,"L2.SST.nc") GE 0)) then begin
    file_is_2019_naming_pattern = 1;
endif

; TODO: Comment out next line once done testing.
;i_out_filename = '/data/dev/scratch/qchau/scratch_temp2/AQUA_QUICKLOOK/AQUA_MODIS.2019289042500.L2.SST.nc'

if (GETENV('GHRSST_OBPG_USE_2019_NAMING_PATTERN') eq 'true') or (file_is_2019_naming_pattern eq 1) then begin
    directory_only = FILE_DIRNAME(i_out_filename);
    basename_only  = FILE_BASENAME(i_out_filename);
    ; Because the basename_only will be something akin AQUA_MODIS.2019289042500.LAC_GSSTN we will need to
    ; rename it to something A2019289042500.LAC_GSSTN

     if (STRPOS(basename_only,"_") GE 0) then begin
         dot_pos = STRPOS(basename_only,".");
         ; Check for 2nd dot perhaps AQUA_MODIS.2019289042500.L2.SST.nc
         second_dot_pos = STRPOS(basename_only,".",dot_pos+1)
         if second_dot_pos EQ -1 then begin
             basename_only = STRMID(basename_only,0,1) + STRMID(basename_only,dot_pos+1);
         endif else begin
             ; If the 2nd dot exists in AQUA_MODIS.2019289042500.L2.SST.nc, we have to fetch up to 2nd dot.
             basename_only = STRMID(basename_only,0,1) + STRMID(basename_only,dot_pos+1,second_dot_pos-dot_pos-1); 
         endelse
         PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:i_out_filename ', i_out_filename
         PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:basename_only ', basename_only
         PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:dot_pos ', dot_pos
         PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:second_dot_pos ', second_dot_pos
     endif

    if (r_day_or_night EQ 'Day') then begin
        ;directory_only = FILE_DIRNAME(i_out_filename);
        ;basename_only  = FILE_BASENAME(i_out_filename);
        if (STRPOS(i_out_filename,".L2.SST.nc") GE 0) then begin
            name_without_extension = FILE_BASENAME(i_out_filename, ".L2.SST.nc");
        endif else begin
            name_without_extension = FILE_BASENAME(i_out_filename, ".L2.SST");
        endelse
        ;i_out_filename  = directory_only + "/" + name_without_extension + ".LAC_GSSTD";
        i_out_filename  = directory_only + "/" + basename_only + ".LAC_GSSTD.nc";
    endif

    if ((r_day_or_night EQ 'Night') || (r_day_or_night EQ 'Mixed')) then begin
        ;directory_only = FILE_DIRNAME(i_out_filename);
        ;basename_only  = FILE_BASENAME(i_out_filename);
        if (STRPOS(i_out_filename,".L2.SST.nc") GE 0) then begin
            name_without_extension = FILE_BASENAME(i_out_filename, ".L2.SST.nc");
        endif else begin
            name_without_extension = FILE_BASENAME(i_out_filename, ".L2_SST");
        endelse
        ;i_out_filename  = directory_only + "/" + name_without_extension + ".LAC_GSSTN";
        i_out_filename  = directory_only + "/" + basename_only + ".LAC_GSSTN.nc";
    endif
    PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:basename_only ', basename_only
    PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:r_day_or_night', r_day_or_night
    PRINT, 'combine_netcdf_sst_and_sst4_files_to_netcdf:i_out_filename ', i_out_filename
    ;STOP
endif else begin
if (r_day_or_night EQ 'Day') then begin
    directory_only = FILE_DIRNAME(i_out_filename);
    basename_only  = FILE_BASENAME(i_out_filename);
    if (STRPOS(i_out_filename,".L2_LAC_SST.nc") GE 0) then begin
        name_without_extension = FILE_BASENAME(i_out_filename, ".L2_LAC_SST.nc");
    endif else begin
        name_without_extension = FILE_BASENAME(i_out_filename, ".L2_LAC_SST");
    endelse
    i_out_filename  = directory_only + "/" + name_without_extension + ".LAC_GSSTD.nc";
    if (debug_mode) then begin
        print, debug_module + "basename_only [" + basename_only + "]";
        print, debug_module + "name_without_extension [" + name_without_extension + "]";
        print, debug_module + "i_out_filename [" + i_out_filename + "]";
    endif
endif

if ((r_day_or_night EQ 'Night') || (r_day_or_night EQ 'Mixed')) then begin
    directory_only = FILE_DIRNAME(i_out_filename);
    basename_only  = FILE_BASENAME(i_out_filename);
    if (STRPOS(i_out_filename,".L2_LAC_SST.nc") GE 0) then begin
        name_without_extension = FILE_BASENAME(i_out_filename, ".L2_LAC_SST.nc");
    endif else begin
        name_without_extension = FILE_BASENAME(i_out_filename, ".L2_LAC_SST");
    endelse
    i_out_filename  = directory_only + "/" + name_without_extension + ".LAC_GSSTN.nc";
    if (debug_mode) then begin
        print, debug_module + "basename_only [" + basename_only + "]";
        print, debug_module + "name_without_extension [" + name_without_extension + "]";
        print, debug_module + "i_out_filename [" + i_out_filename + "]";
    endif
endif
endelse

;
; Set attributes to be used as global attributes in output file.
;

l_sensor_name = '';
l_platform = '';
l_title    = '';
l_dsd_entry_id = '';

; Prepend a pre-existing.

l_warning = "; WARNING Some applications are unable to properly handle signed byte values. If values are encountered > 127, please subtract 256 from this reported value";
l_comment = const_comment + "; " + r_day_or_night + ', Start Node:' + r_start_node + ', End Node:' $
                                 + r_end_node + l_warning;

if ((r_sensor_name EQ 'MODISA') OR (r_sensor_name EQ 'HMODISA')) then begin
    l_sensor_name = 'MODIS_A';
    l_platform = 'Aqua';
    l_title    = 'MODIS Aqua L2P SST';
endif else begin
    if ((r_sensor_name EQ 'MODIST') OR (r_sensor_name EQ 'HMODIST')) then begin
        l_sensor_name = 'MODIS_T';
        l_platform = 'Terra';
        l_title    = 'MODIS Terra L2P SST';
    endif
endelse

; The NetCDF file for test files from 2007 has the r_sensor_name value as 'MODIS'
; We have to determine if it is Aqua or Terra from the first character of the name.

if (l_title EQ '') then begin
    ; Get the name only
    name_only = FILE_BASENAME(i_sst_filename);
    first_character = STRMID(name_only,0,1);
    if (first_character EQ 'A') then begin
        l_sensor_name = 'MODIS_A';
        l_platform = 'Aqua';
        l_title    = 'MODIS Aqua L2P SST';
    endif

    if (first_character EQ 'T') then begin
        l_sensor_name = 'MODIS_T';
        l_platform = 'Terra';
        l_title    = 'MODIS Terra L2P SST';
    endif
endif

; Throw an ERROR sigevent if the title cannot be determined.
if (l_title EQ '') then begin
    msg_type = "error";
    msg = "Cannot determine if MODIS_A or MODIS_T based on instrument attribute [" + r_sensor_name + "] from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    exit, status=49   ; Indicate an error that should prompt notification;
endif

l_dsd_entry_id = 'JPL-L2P-' + l_sensor_name;

;
; Create a NetCDF output file.
;

; BEGIN_BLOCK_0
EXECUTE_THIS_BLOCK = 1;

if (EXECUTE_THIS_BLOCK EQ 1) then begin
    ; Tweak the long, float, and string attribute names back to the old name so we don't have to change the MODIS L2P Processing code
    ; which receives the output of this program as input.

    long_attributes_names = ['Number_of_Scan_Lines',$
                             'Pixels_per_Scan_Line',$
                             'Start_Year',          $
                             'Start_Day',           $
                             'Start_Millisec',      $
                             'End_Year',            $
                             'End_Day',             $
                             'End_Millisec']

    float_attributes_names = ['Northernmost_Latitude',$
                              'Southernmost_Latitude',$
                              'Easternmost_Longitude',$
                              'Westernmost_Longitude'];
    string_index = 0;
    string_attributes_names[string_index] = 'Start_Time';
    string_index = string_index + 1;
    string_attributes_names[string_index] = 'End_Time';
    string_index = string_index + 1;
    string_attributes_names[string_index] = 'Sensor_Name';
    string_index = string_index + 1;
    string_attributes_names[string_index] = 'Start_Node';
    string_index = string_index + 1;
    string_attributes_names[string_index] = 'End_Node';
    string_index = string_index + 1;
    string_attributes_names[string_index] = 'Day_or_Night';

    if (debug_mode) then begin
        for i = 0, (size(long_attributes_names,/N_ELEMENTS) - 1) do begin
            print, debug_module, long_attributes_names[i], ' [', long_attributes_values[i], ']'; 
        end
        for i = 0, (size(float_attributes_names,/N_ELEMENTS) - 1) do begin
            print, debug_module, float_attributes_names[i], ' [', float_attributes_values[i], ']'; 
        end
        for i = 0, (size(string_attributes_names,/N_ELEMENTS) - 1) do begin
            print, debug_module, string_attributes_names[i], ' [', string_attributes_values[i], ']'; 
        end
        print, debug_module, 'l_title ', ' [', l_title, ']';
    endif

    r_status = create_modis_netcdf_file(i_out_filename,$
                                     long_attributes_names,$
                                     long_attributes_values,$
                                     float_attributes_names,$
                                     float_attributes_values,$
                                     string_attributes_names,$
                                     string_attributes_values,$
                                     l_title);

    if (GETENV('GHRSST_MODIS_COMBINER_FAILED_OUTPUT_CREATION_TEST') EQ 'true') then r_status = FAILURE;

    if (r_status NE SUCCESS) then begin
        msg_type = "error";
        msg = "Cannot create output file " + i_out_filename;
        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);
        donotcare = clean_up_combiner(routine_name,i_out_filename);
        ; Must return immediately.
        exit, status=39    ; Indicate an error that should be quarantined
    endif
endif
; END_BLOCK_0

;--------------------------------------------------------------------------------
; Read cntl_pt_cols & cntl_pt_rows variables from NetCDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'cntl_pt_cols';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_CONTROL_POINT_COLS_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
r_dataset_array = *(o_data_variable_structure.s_variable_array);

PTR_FREE,o_data_variable_structure.s_variable_array;
data_type_as_int = SIZE(r_dataset_array,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);

; If the unit is not provided, we must fill it with some value otherwise IDL will fail. 
if (r_units EQ '') then begin
    r_units = 'none';
endif

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

; From this point on, if there is an error, the created output file will be removed so as not to allow it to be process by the MODIS L2P Processing.
if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

if (debug_mode) then begin
    print, routine_name,'i_sst_filename        ', i_sst_filename;
    print, routine_name,'i_variable_short_name ', i_variable_short_name;
    print, routine_name,'r_long_name           ', r_long_name;
    print, routine_name,'r_units               ', r_units;
    print, routine_name,'r_data_type           ', r_data_type;
    print, routine_name,'r_fill_value          ', r_fill_value;
    print, routine_name,'r_valid_min           ', r_valid_min;
    print, routine_name,'r_valid_max           ', r_valid_max;
endif

r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept,$
                                         r_fill_value,r_valid_min,r_valid_max);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_CONTROL_POINT_COLS_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot write variable " + i_variable_short_name + " to file " + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

i_variable_short_name = 'cntl_pt_rows';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_CONTROL_POINT_ROWS_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

data_type_as_int = SIZE(r_dataset_array,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);

; If the unit is not provided, we must fill it with some value otherwise IDL will fail. 
if (r_units EQ '') then begin
    r_units = 'none';
endif

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

if (debug_mode) then begin
    print, routine_name,'i_sst_filename        ', i_sst_filename;
    print, routine_name,'i_variable_short_name ', i_variable_short_name;
    print, routine_name,'r_long_name           ', r_long_name;
    print, routine_name,'r_units               ', r_units;
    print, routine_name,'r_data_type           ', r_data_type;
    print, routine_name,'r_fill_value          ', r_fill_value;
    print, routine_name,'r_valid_min           ', r_valid_min;
    print, routine_name,'r_valid_max           ', r_valid_max;
endif

r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept,$
                                         r_fill_value,r_valid_min,r_valid_max);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_CONTROL_POINT_ROWS_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot write variable " + i_variable_short_name + " to file " + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

i_variable_short_name = 'l2_flags';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_L2_FLAGS_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

data_type_as_int = SIZE(r_dataset_array,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);

; If the unit is not provided, we must fill it with some value otherwise IDL will fail. 
if (r_units EQ '') then begin
    r_units = 'none';
endif

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

if (debug_mode) then begin
    print, routine_name, 'i_sst_filename        ', i_sst_filename;
    print, routine_name, 'i_variable_short_name ', i_variable_short_name;
    print, routine_name, 'r_long_name           ', r_long_name;
    print, routine_name, 'r_units               ', r_units;
    print, routine_name, 'r_data_type           ', r_data_type;
endif

r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_L2_FLAGS_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot write variable " + i_variable_short_name + " to file " + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

i_variable_short_name = 'longitude';
r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_LONGITUDE_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);

    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

data_type_as_int = SIZE(r_dataset_array,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

if (debug_mode) then begin
    print, routine_name, 'i_sst_filename        ', i_sst_filename;
    print, routine_name, 'i_variable_short_name ', i_variable_short_name;
    print, routine_name, 'r_long_name           ', r_long_name;
    print, routine_name, 'r_units               ', r_units;
    print, routine_name, 'r_data_type           ', r_data_type;
    print, routine_name, 'r_fill_value          ', r_fill_value;
    print, routine_name, 'r_valid_min           ', r_valid_min;
    print, routine_name, 'r_valid_max           ', r_valid_max;
endif


r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept,$
                                         r_fill_value,r_valid_min,r_valid_max);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_LONGITUDE_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_variable_short_name + ' to file ' + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    exit, status=39    ; Indicate an error that should be quarantined
endif

;
; Read the latitude subintervals.
;

i_variable_short_name = 'latitude';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_LATITUDE_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read variable " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

data_type_as_int = SIZE(r_dataset_array,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

if (debug_mode) then begin
    print, routine_name, 'i_sst_filename        ', i_sst_filename;
    print, routine_name, 'i_variable_short_name ', i_variable_short_name;
    print, routine_name, 'r_long_name           ', r_long_name;
    print, routine_name, 'r_units               ', r_units;
    print, routine_name, 'r_data_type           ', r_data_type;
    print, routine_name, 'r_fill_value          ', r_fill_value;
endif

r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept,$
                                         r_fill_value,r_valid_min,r_valid_max);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_LATITUDE_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_variable_short_name + ' to file ' + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

; BEGIN_BLOCK_2
EXECUTE_THIS_BLOCK = 1;

if (EXECUTE_THIS_BLOCK EQ 1) then begin

i_variable_short_name = 'sst';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_SST_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,'Cannot read variable ' + i_variable_short_name + ' from file ' + i_sst_filename);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

data_type_as_int = SIZE(r_dataset_array,/TYPE);
r_data_type = convert_int_type_to_char_type(data_type_as_int);

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

;
; Something odd:  The type of sst in the ncdump is short:
; group: geophysical_data {
;  variables:
;       short sst(Number_of_Scan_Lines, Pixels_per_Scan_Line) ;
;               sst:long_name = "Sea Surface Temperature" ;
;               sst:scale_factor = 0.005f ;
;               sst:add_offset = 0.f ;
;               sst:units = "degrees-C" ;
;               sst:standard_name = "sea_surface_temperature" ;
;               sst:_FillValue = -32767s ;
;               sst:valid_min = -1000s ;
;               sst:valid_max = 10000s ;
;
; but the type returned from NCDF_VARGET is of type INT
; For now, we will reset the type to SHORT;
;r_data_type = 'SHORT';

if (debug_mode) then begin
    print, routine_name, 'i_sst_filename        ', i_sst_filename;
    print, routine_name, 'i_variable_short_name ', i_variable_short_name;
    print, routine_name, 'r_long_name           ', r_long_name;
    print, routine_name, 'r_units               ', r_units;
    print, routine_name, 'r_data_type           ', r_data_type;
    print, routine_name, 'r_fill_value          ', r_fill_value;
endif

r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept,$
                                         r_fill_value,r_valid_min,r_valid_max);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_SST_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot write variable ' + i_variable_short_name + ' to file ' + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

; END_BLOCK_2
endif


;--------------------------------------------------------------------------------
; Read msec from NetCDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

; BEGIN_BLOCK_3
EXECUTE_THIS_BLOCK = 1; 

if (EXECUTE_THIS_BLOCK EQ 1) then begin

i_variable_short_name = 'msec';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_MSEC_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot read attribute " + i_variable_short_name + " from file " + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

r_dataset_array = *(o_data_variable_structure.s_variable_array);
PTR_FREE,o_data_variable_structure.s_variable_array;

r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
data_type_as_int = SIZE(r_dataset_array,/TYPE);

r_data_type = convert_int_type_to_char_type(data_type_as_int);

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

if (debug_mode) then begin
    print, routine_name, 'i_sst_filename        ', i_sst_filename;
    print, routine_name, 'i_variable_short_name ', i_variable_short_name;
    print, routine_name, 'r_long_name           ', r_long_name;
    print, routine_name, 'r_units               ', r_units;
    print, routine_name, 'r_data_type           ', r_data_type;
endif

r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                         r_dataset_array, r_long_name,$
                                         r_units,r_data_type,r_slope,r_intercept);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_MSEC_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

if (r_status NE SUCCESS) then begin
    msg_type = "error";
    msg = "Cannot write variable " + i_variable_short_name + " to file " + i_out_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

endif
; END_BLOCK_3


; BEGIN_BLOCK_4
EXECUTE_THIS_BLOCK = 1; 

if (EXECUTE_THIS_BLOCK EQ 1) then begin

;--------------------------------------------------------------------------------
; Read bias_sst from NetCDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'bias_sst';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_BIAS_SST_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);

    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif else begin

    r_dataset_array = *(o_data_variable_structure.s_variable_array);
    PTR_FREE,o_data_variable_structure.s_variable_array;

    r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
    r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
    r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
    r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
    r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
    r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
    r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
    data_type_as_int = SIZE(r_dataset_array,/TYPE);
    r_data_type = convert_int_type_to_char_type(data_type_as_int);

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

    if (debug_mode) then begin
        print, routine_name, 'INFO, i_variable_short_name  = ', i_variable_short_name;
        print, routine_name, 'INFO, r_slope                = ', r_slope;
        print, routine_name, 'INFO, r_intercept            = ', r_intercept;
        print, routine_name, 'INFO, r_units                = ', r_units;
        print, routine_name, 'INFO, r_long_name            = ', r_long_name;
    endif

    r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                             r_dataset_array, r_long_name,$
                                             r_units,r_data_type,r_slope,r_intercept,$
                                             r_fill_value,r_valid_min,r_valid_max);

    if (GETENV('GHRSST_MODIS_COMBINER_FAILED_BIAS_SST_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + i_variable_short_name + ' to file ' + i_out_filename;
        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);
        donotcare = clean_up_combiner(routine_name,i_out_filename);
        ; Must return immediately.
        exit, status=39    ; Indicate an error that should be quarantined
    endif

endelse

;--------------------------------------------------------------------------------
; Read stdv_sst from NetCDF file. and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'stdv_sst';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                    i_variable_short_name,$
                                    o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_STDV_SST_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif else begin

    r_dataset_array = *(o_data_variable_structure.s_variable_array);
    PTR_FREE,o_data_variable_structure.s_variable_array;

    r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
    r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
    r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
    r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
    r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
    r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
    r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
    data_type_as_int = SIZE(r_dataset_array,/TYPE);
    r_data_type = convert_int_type_to_char_type(data_type_as_int);

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

    if (debug_mode) then begin
        print, routine_name, 'INFO, i_variable_short_name  = ', i_variable_short_name;
        print, routine_name, 'INFO, r_slope                = ', r_slope;
        print, routine_name, 'INFO, r_intercept            = ', r_intercept;
        print, routine_name, 'INFO, r_units                = ', r_units;
        print, routine_name, 'INFO, r_long_name            = ', r_long_name;
    endif

    r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                             r_dataset_array, r_long_name,$
                                             r_units,r_data_type,r_slope,r_intercept,$
                                             r_fill_value,r_valid_min,r_valid_max);

    if (GETENV('GHRSST_MODIS_COMBINER_FAILED_STDV_SST_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + i_variable_short_name + ' to file ' + i_out_filename;
        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);
        donotcare = clean_up_combiner(routine_name,i_out_filename);
        ; Must return immediately.
        exit, status=39    ; Indicate an error that should be quarantined
    endif
endelse

;--------------------------------------------------------------------------------
; Read qual_sst from NetCDF file and write to NetCDF file.
;--------------------------------------------------------------------------------

i_variable_short_name = 'qual_sst';

r_status = read_netcdf_one_variable(i_sst_filename,$
                                     i_variable_short_name,$
                                     o_data_variable_structure);

if (GETENV('GHRSST_MODIS_COMBINER_FAILED_QUAL_SST_VARIABLE_READ_TEST') EQ 'true') then r_status = FAILURE;

if (r_status EQ FAILURE) then begin
    msg_type = "error";
    msg = 'Cannot read variable ' + i_variable_short_name + ' from file ' + i_sst_filename;
    donotcare = echo_message_to_screen(routine_name,msg,msg_type);
    donotcare = error_log_writer(routine_name,msg);
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif else begin
    r_dataset_array = *(o_data_variable_structure.s_variable_array);
    PTR_FREE,o_data_variable_structure.s_variable_array;

    r_status = find_netcdf_variable_attribute_info('scale_factor',o_data_variable_structure.s_attributes_array,r_slope);
    r_status = find_netcdf_variable_attribute_info('add_offset',o_data_variable_structure.s_attributes_array,r_intercept);
    r_status = find_netcdf_variable_attribute_info('units',o_data_variable_structure.s_attributes_array,r_units);
    r_status = find_netcdf_variable_attribute_info('long_name',o_data_variable_structure.s_attributes_array,r_long_name);
    r_status = find_netcdf_variable_attribute_info('_FillValue',o_data_variable_structure.s_attributes_array,r_fill_value);
    r_status = find_netcdf_variable_attribute_info('valid_min',o_data_variable_structure.s_attributes_array,r_valid_min);
    r_status = find_netcdf_variable_attribute_info('valid_max',o_data_variable_structure.s_attributes_array,r_valid_max);
    data_type_as_int = SIZE(r_dataset_array,/TYPE);
    r_data_type = convert_int_type_to_char_type(data_type_as_int);

    ; If the unit is not provided, we must fill it with some value otherwise IDL will fail. 
    if (r_units EQ '') then begin
        r_units = 'none';
    endif

    ; If the scale_factor and offset are not provided, we set them to 1.0 and 0.0 respectively
    if (r_slope EQ '')     then r_slope = 1.0; 
    if (r_intercept EQ '') then r_intercept = 0.0;

; Validate the variable dimensions and type.

o_variable_valid_flag = validate_variable_dimensions($
                            i_sst_filename,$
                            i_variable_short_name,$
                            num_lons,$       ; Same as Number_of_Scan_Lines = 2030
                            num_lats,$       ; Same as pixel_control_points = 1354
                            r_dataset_array);

if (o_variable_valid_flag NE 1) then begin
    donotcare = clean_up_combiner(routine_name,i_out_filename);
    ; Must return immediately.
    exit, status=39    ; Indicate an error that should be quarantined
endif

    r_status = write_control_points_variable_to_netcdf(i_out_filename,i_variable_short_name,$
                                             r_dataset_array, r_long_name,$
                                             r_units,r_data_type,r_slope,r_intercept,$
                                             r_fill_value,r_valid_min,r_valid_max);

    if (GETENV('GHRSST_MODIS_COMBINER_FAILED_QUAL_SST_VARIABLE_WRITE_TEST') EQ 'true') then r_status = FAILURE;

    if (r_status EQ FAILURE) then begin
        msg_type = "error";
        msg = 'Cannot write variable ' + i_variable_short_name + ' to file ' + i_out_filename;
        donotcare = echo_message_to_screen(routine_name,msg,msg_type);
        donotcare = error_log_writer(routine_name,msg);
        donotcare = clean_up_combiner(routine_name,i_out_filename);
        ; Must return immediately.
        exit, status=39    ; Indicate an error that should be quarantined
    endif
endelse

; END_BLOCK_4
endif

;--------------------------------------------------------------------------------
; Combine the SST4 file if it is available.
; Combine the OC   file if it is available.
;
; Note: Since the night and day variables are optional, we don't check for the returned
;       status.  If there is an error, it will be raise from within each combine_additional_night* and combine_additional_day* function.
;--------------------------------------------------------------------------------

if (i_sst4_filename NE 'DUMMY_SST4_FILENAME') then begin
    if (STRPOS(i_sst4_filename,".nc") GE 0) then begin
        if (debug_mode) then begin
            print, debug_module, 'Using combine_additional_night_netcdf_variables_to_netcdf for = ', i_sst4_filename;
        endif
        l_status = combine_additional_night_netcdf_variables_to_netcdf(i_sst4_filename,num_lons,num_lats,i_out_filename);
    endif else begin
        if (debug_mode) then begin
            print, debug_module, 'Using combine_additional_night_hdf_variables_to_netcdf for = ', i_sst4_filename;
        endif
        l_status = combine_additional_night_hdf_variables_to_netcdf(i_sst4_filename,i_out_filename);
    endelse
    if (l_status EQ FAILURE) then begin
        exit, status=39
    endif
endif

if (i_oc_filename NE 'DUMMY_OC_FILENAME') then begin
    ; The following logic is required dude to OBPG leaving the OC file in HDF format for some time while the SST/SST4 will in NetCDF format.
    ; If the file name contains ".nc" we use the NetCDF version of the combiner.  If it does not, we use the HDF version.
    if (STRPOS(i_oc_filename,".nc") GE 0) then begin
        if (debug_mode) then begin
            print, debug_module, 'Using combine_additional_day_netcdf_variables for = ', i_oc_filename;
        endif
        l_status = combine_additional_day_netcdf_variables_to_netcdf(i_oc_filename,num_lons,num_lats,i_out_filename);
    endif else begin
        if (debug_mode) then begin
            print, debug_module, 'Using combine_additional_day_hdf_variables_to_netcdf for = ', i_oc_filename;
        endif
        l_status = combine_additional_day_hdf_variables_to_netcdf(i_oc_filename,i_out_filename);
    endelse
endif

combiner_end = SYSTIME(/SECONDS);
combiner_time = combiner_end - combiner_start;
print, debug_module + 'COMBINER_END ' + SYSTIME();
print, debug_module + 'COMBINER_TIME ', combiner_time, ' ' + i_out_filename, FORMAT='(A,F0.2,A)';

; ---------- Close up shop ---------- 

if (debug_mode) then begin
print, debug_module, 'Input files:';
print, debug_module, 'i_sst_filename  = ', i_sst_filename ;
print, debug_module, 'i_sst4_filename = ', i_sst4_filename;
print, debug_module, 'i_oc_filename   = ', i_oc_filename;
print, debug_module, 'Output file:';
print, debug_module, 'i_out_filename  = ', i_out_filename;
endif

end
